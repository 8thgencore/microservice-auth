// Code generated by http://github.com/gojuno/minimock (v3.4.2). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/8thgencore/microservice-auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// AuthServiceMock implements service.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetAccessToken   func(ctx context.Context, refreshToken string)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mAuthServiceMockGetAccessToken

	funcGetRefreshToken          func(ctx context.Context, oldRefreshToken string) (s1 string, err error)
	inspectFuncGetRefreshToken   func(ctx context.Context, oldRefreshToken string)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mAuthServiceMockGetRefreshToken

	funcLogin          func(ctx context.Context, creds *model.UserCreds) (tp1 *model.TokenPair, err error)
	inspectFuncLogin   func(ctx context.Context, creds *model.UserCreds)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcLogout          func(ctx context.Context, refreshToken string) (err error)
	inspectFuncLogout   func(ctx context.Context, refreshToken string)
	afterLogoutCounter  uint64
	beforeLogoutCounter uint64
	LogoutMock          mAuthServiceMockLogout
}

// NewAuthServiceMock returns a mock for service.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAccessTokenMock = mAuthServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*AuthServiceMockGetAccessTokenParams{}

	m.GetRefreshTokenMock = mAuthServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*AuthServiceMockGetRefreshTokenParams{}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.LogoutMock = mAuthServiceMockLogout{mock: m}
	m.LogoutMock.callArgs = []*AuthServiceMockLogoutParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockGetAccessToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetAccessTokenExpectation
	expectations       []*AuthServiceMockGetAccessTokenExpectation

	callArgs []*AuthServiceMockGetAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetAccessTokenExpectation specifies expectation struct of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetAccessTokenParams
	paramPtrs *AuthServiceMockGetAccessTokenParamPtrs
	results   *AuthServiceMockGetAccessTokenResults
	Counter   uint64
}

// AuthServiceMockGetAccessTokenParams contains parameters of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// AuthServiceMockGetAccessTokenParamPtrs contains pointers to parameters of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// AuthServiceMockGetAccessTokenResults contains results of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Optional() *mAuthServiceMockGetAccessToken {
	mmGetAccessToken.optional = true
	return mmGetAccessToken
}

// Expect sets up expected params for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Expect(ctx context.Context, refreshToken string) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by ExpectParams functions")
	}

	mmGetAccessToken.defaultExpectation.params = &AuthServiceMockGetAccessTokenParams{ctx, refreshToken}
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Return(s1 string, err error) *AuthServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &AuthServiceMockGetAccessTokenResults{s1, err}
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the AuthService.GetAccessToken method
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *AuthServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the AuthService.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the AuthService.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	return mmGetAccessToken.mock
}

// When sets expectation for the AuthService.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) When(ctx context.Context, refreshToken string) *AuthServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &AuthServiceMockGetAccessTokenExpectation{
		mock:   mmGetAccessToken.mock,
		params: &AuthServiceMockGetAccessTokenParams{ctx, refreshToken},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetAccessTokenExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.GetAccessToken should be invoked
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Times(n uint64) *mAuthServiceMockGetAccessToken {
	if n == 0 {
		mmGetAccessToken.mock.t.Fatalf("Times of AuthServiceMock.GetAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessToken.expectedInvocations, n)
	return mmGetAccessToken
}

func (mmGetAccessToken *mAuthServiceMockGetAccessToken) invocationsDone() bool {
	if len(mmGetAccessToken.expectations) == 0 && mmGetAccessToken.defaultExpectation == nil && mmGetAccessToken.mock.funcGetAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.mock.afterGetAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessToken implements service.AuthService
func (mmGetAccessToken *AuthServiceMock) GetAccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, refreshToken)
	}

	mm_params := AuthServiceMockGetAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameter refreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the AuthServiceMock.GetAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, refreshToken)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to AuthServiceMock.GetAccessToken. %v %v", ctx, refreshToken)
	return
}

// GetAccessTokenAfterCounter returns a count of finished AuthServiceMock.GetAccessToken invocations
func (mmGetAccessToken *AuthServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of AuthServiceMock.GetAccessToken invocations
func (mmGetAccessToken *AuthServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Calls() []*AuthServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetAccessTokenDone() bool {
	if m.GetAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenMock.invocationsDone()
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetAccessToken with params: %#v", *e.params)
		}
	}

	afterGetAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && afterGetAccessTokenCounter < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.GetAccessToken")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetAccessToken with params: %#v", *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && afterGetAccessTokenCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.GetAccessToken")
	}

	if !m.GetAccessTokenMock.invocationsDone() && afterGetAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetAccessToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenMock.expectedInvocations), afterGetAccessTokenCounter)
	}
}

type mAuthServiceMockGetRefreshToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetRefreshTokenExpectation
	expectations       []*AuthServiceMockGetRefreshTokenExpectation

	callArgs []*AuthServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetRefreshTokenExpectation specifies expectation struct of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetRefreshTokenParams
	paramPtrs *AuthServiceMockGetRefreshTokenParamPtrs
	results   *AuthServiceMockGetRefreshTokenResults
	Counter   uint64
}

// AuthServiceMockGetRefreshTokenParams contains parameters of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenParams struct {
	ctx             context.Context
	oldRefreshToken string
}

// AuthServiceMockGetRefreshTokenParamPtrs contains pointers to parameters of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenParamPtrs struct {
	ctx             *context.Context
	oldRefreshToken *string
}

// AuthServiceMockGetRefreshTokenResults contains results of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Optional() *mAuthServiceMockGetRefreshToken {
	mmGetRefreshToken.optional = true
	return mmGetRefreshToken
}

// Expect sets up expected params for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Expect(ctx context.Context, oldRefreshToken string) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by ExpectParams functions")
	}

	mmGetRefreshToken.defaultExpectation.params = &AuthServiceMockGetRefreshTokenParams{ctx, oldRefreshToken}
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRefreshToken
}

// ExpectOldRefreshTokenParam2 sets up expected param oldRefreshToken for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) ExpectOldRefreshTokenParam2(oldRefreshToken string) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.oldRefreshToken = &oldRefreshToken

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, oldRefreshToken string)) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Return(s1 string, err error) *AuthServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &AuthServiceMockGetRefreshTokenResults{s1, err}
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the AuthService.GetRefreshToken method
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Set(f func(ctx context.Context, oldRefreshToken string) (s1 string, err error)) *AuthServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthService.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthService.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	return mmGetRefreshToken.mock
}

// When sets expectation for the AuthService.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) When(ctx context.Context, oldRefreshToken string) *AuthServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &AuthServiceMockGetRefreshTokenExpectation{
		mock:   mmGetRefreshToken.mock,
		params: &AuthServiceMockGetRefreshTokenParams{ctx, oldRefreshToken},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetRefreshTokenExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.GetRefreshToken should be invoked
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Times(n uint64) *mAuthServiceMockGetRefreshToken {
	if n == 0 {
		mmGetRefreshToken.mock.t.Fatalf("Times of AuthServiceMock.GetRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshToken.expectedInvocations, n)
	return mmGetRefreshToken
}

func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) invocationsDone() bool {
	if len(mmGetRefreshToken.expectations) == 0 && mmGetRefreshToken.defaultExpectation == nil && mmGetRefreshToken.mock.funcGetRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.mock.afterGetRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshToken implements service.AuthService
func (mmGetRefreshToken *AuthServiceMock) GetRefreshToken(ctx context.Context, oldRefreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, oldRefreshToken)
	}

	mm_params := AuthServiceMockGetRefreshTokenParams{ctx, oldRefreshToken}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetRefreshTokenParams{ctx, oldRefreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.oldRefreshToken != nil && !minimock.Equal(*mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken) {
				mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameter oldRefreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken, minimock.Diff(*mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the AuthServiceMock.GetRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, oldRefreshToken)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to AuthServiceMock.GetRefreshToken. %v %v", ctx, oldRefreshToken)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished AuthServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *AuthServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of AuthServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *AuthServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Calls() []*AuthServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetRefreshTokenDone() bool {
	if m.GetRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenMock.invocationsDone()
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetRefreshToken with params: %#v", *e.params)
		}
	}

	afterGetRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && afterGetRefreshTokenCounter < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.GetRefreshToken")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetRefreshToken with params: %#v", *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && afterGetRefreshTokenCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.GetRefreshToken")
	}

	if !m.GetRefreshTokenMock.invocationsDone() && afterGetRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetRefreshToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenMock.expectedInvocations), afterGetRefreshTokenCounter)
	}
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockLoginParams
	paramPtrs *AuthServiceMockLoginParamPtrs
	results   *AuthServiceMockLoginResults
	Counter   uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx   context.Context
	creds *model.UserCreds
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx   *context.Context
	creds **model.UserCreds
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	tp1 *model.TokenPair
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, creds *model.UserCreds) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, creds}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogin
}

// ExpectCredsParam2 sets up expected param creds for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCredsParam2(creds *model.UserCreds) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.creds = &creds

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, creds *model.UserCreds)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(tp1 *model.TokenPair, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{tp1, err}
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, creds *model.UserCreds) (tp1 *model.TokenPair, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, creds *model.UserCreds) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &AuthServiceMockLoginParams{ctx, creds},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(tp1 *model.TokenPair, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{tp1, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements service.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, creds *model.UserCreds) (tp1 *model.TokenPair, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, creds)
	}

	mm_params := AuthServiceMockLoginParams{ctx, creds}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, creds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.creds != nil && !minimock.Equal(*mm_want_ptrs.creds, mm_got.creds) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter creds, want: %#v, got: %#v%s\n", *mm_want_ptrs.creds, mm_got.creds, minimock.Diff(*mm_want_ptrs.creds, mm_got.creds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, creds)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v", ctx, creds)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login with params: %#v", *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Login")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Login")
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), afterLoginCounter)
	}
}

type mAuthServiceMockLogout struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLogoutExpectation
	expectations       []*AuthServiceMockLogoutExpectation

	callArgs []*AuthServiceMockLogoutParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockLogoutExpectation specifies expectation struct of the AuthService.Logout
type AuthServiceMockLogoutExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockLogoutParams
	paramPtrs *AuthServiceMockLogoutParamPtrs
	results   *AuthServiceMockLogoutResults
	Counter   uint64
}

// AuthServiceMockLogoutParams contains parameters of the AuthService.Logout
type AuthServiceMockLogoutParams struct {
	ctx          context.Context
	refreshToken string
}

// AuthServiceMockLogoutParamPtrs contains pointers to parameters of the AuthService.Logout
type AuthServiceMockLogoutParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// AuthServiceMockLogoutResults contains results of the AuthService.Logout
type AuthServiceMockLogoutResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogout *mAuthServiceMockLogout) Optional() *mAuthServiceMockLogout {
	mmLogout.optional = true
	return mmLogout
}

// Expect sets up expected params for AuthService.Logout
func (mmLogout *mAuthServiceMockLogout) Expect(ctx context.Context, refreshToken string) *mAuthServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &AuthServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.paramPtrs != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by ExpectParams functions")
	}

	mmLogout.defaultExpectation.params = &AuthServiceMockLogoutParams{ctx, refreshToken}
	for _, e := range mmLogout.expectations {
		if minimock.Equal(e.params, mmLogout.defaultExpectation.params) {
			mmLogout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogout.defaultExpectation.params)
		}
	}

	return mmLogout
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Logout
func (mmLogout *mAuthServiceMockLogout) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &AuthServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.params != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Expect")
	}

	if mmLogout.defaultExpectation.paramPtrs == nil {
		mmLogout.defaultExpectation.paramPtrs = &AuthServiceMockLogoutParamPtrs{}
	}
	mmLogout.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogout
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.Logout
func (mmLogout *mAuthServiceMockLogout) ExpectRefreshTokenParam2(refreshToken string) *mAuthServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &AuthServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.params != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Expect")
	}

	if mmLogout.defaultExpectation.paramPtrs == nil {
		mmLogout.defaultExpectation.paramPtrs = &AuthServiceMockLogoutParamPtrs{}
	}
	mmLogout.defaultExpectation.paramPtrs.refreshToken = &refreshToken

	return mmLogout
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Logout
func (mmLogout *mAuthServiceMockLogout) Inspect(f func(ctx context.Context, refreshToken string)) *mAuthServiceMockLogout {
	if mmLogout.mock.inspectFuncLogout != nil {
		mmLogout.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Logout")
	}

	mmLogout.mock.inspectFuncLogout = f

	return mmLogout
}

// Return sets up results that will be returned by AuthService.Logout
func (mmLogout *mAuthServiceMockLogout) Return(err error) *AuthServiceMock {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &AuthServiceMockLogoutExpectation{mock: mmLogout.mock}
	}
	mmLogout.defaultExpectation.results = &AuthServiceMockLogoutResults{err}
	return mmLogout.mock
}

// Set uses given function f to mock the AuthService.Logout method
func (mmLogout *mAuthServiceMockLogout) Set(f func(ctx context.Context, refreshToken string) (err error)) *AuthServiceMock {
	if mmLogout.defaultExpectation != nil {
		mmLogout.mock.t.Fatalf("Default expectation is already set for the AuthService.Logout method")
	}

	if len(mmLogout.expectations) > 0 {
		mmLogout.mock.t.Fatalf("Some expectations are already set for the AuthService.Logout method")
	}

	mmLogout.mock.funcLogout = f
	return mmLogout.mock
}

// When sets expectation for the AuthService.Logout which will trigger the result defined by the following
// Then helper
func (mmLogout *mAuthServiceMockLogout) When(ctx context.Context, refreshToken string) *AuthServiceMockLogoutExpectation {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("AuthServiceMock.Logout mock is already set by Set")
	}

	expectation := &AuthServiceMockLogoutExpectation{
		mock:   mmLogout.mock,
		params: &AuthServiceMockLogoutParams{ctx, refreshToken},
	}
	mmLogout.expectations = append(mmLogout.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Logout return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLogoutExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockLogoutResults{err}
	return e.mock
}

// Times sets number of times AuthService.Logout should be invoked
func (mmLogout *mAuthServiceMockLogout) Times(n uint64) *mAuthServiceMockLogout {
	if n == 0 {
		mmLogout.mock.t.Fatalf("Times of AuthServiceMock.Logout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogout.expectedInvocations, n)
	return mmLogout
}

func (mmLogout *mAuthServiceMockLogout) invocationsDone() bool {
	if len(mmLogout.expectations) == 0 && mmLogout.defaultExpectation == nil && mmLogout.mock.funcLogout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogout.mock.afterLogoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Logout implements service.AuthService
func (mmLogout *AuthServiceMock) Logout(ctx context.Context, refreshToken string) (err error) {
	mm_atomic.AddUint64(&mmLogout.beforeLogoutCounter, 1)
	defer mm_atomic.AddUint64(&mmLogout.afterLogoutCounter, 1)

	if mmLogout.inspectFuncLogout != nil {
		mmLogout.inspectFuncLogout(ctx, refreshToken)
	}

	mm_params := AuthServiceMockLogoutParams{ctx, refreshToken}

	// Record call args
	mmLogout.LogoutMock.mutex.Lock()
	mmLogout.LogoutMock.callArgs = append(mmLogout.LogoutMock.callArgs, &mm_params)
	mmLogout.LogoutMock.mutex.Unlock()

	for _, e := range mmLogout.LogoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLogout.LogoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogout.LogoutMock.defaultExpectation.Counter, 1)
		mm_want := mmLogout.LogoutMock.defaultExpectation.params
		mm_want_ptrs := mmLogout.LogoutMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLogoutParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogout.t.Errorf("AuthServiceMock.Logout got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmLogout.t.Errorf("AuthServiceMock.Logout got unexpected parameter refreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogout.t.Errorf("AuthServiceMock.Logout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogout.LogoutMock.defaultExpectation.results
		if mm_results == nil {
			mmLogout.t.Fatal("No results are set for the AuthServiceMock.Logout")
		}
		return (*mm_results).err
	}
	if mmLogout.funcLogout != nil {
		return mmLogout.funcLogout(ctx, refreshToken)
	}
	mmLogout.t.Fatalf("Unexpected call to AuthServiceMock.Logout. %v %v", ctx, refreshToken)
	return
}

// LogoutAfterCounter returns a count of finished AuthServiceMock.Logout invocations
func (mmLogout *AuthServiceMock) LogoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.afterLogoutCounter)
}

// LogoutBeforeCounter returns a count of AuthServiceMock.Logout invocations
func (mmLogout *AuthServiceMock) LogoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.beforeLogoutCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Logout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogout *mAuthServiceMockLogout) Calls() []*AuthServiceMockLogoutParams {
	mmLogout.mutex.RLock()

	argCopy := make([]*AuthServiceMockLogoutParams, len(mmLogout.callArgs))
	copy(argCopy, mmLogout.callArgs)

	mmLogout.mutex.RUnlock()

	return argCopy
}

// MinimockLogoutDone returns true if the count of the Logout invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLogoutDone() bool {
	if m.LogoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogoutMock.invocationsDone()
}

// MinimockLogoutInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLogoutInspect() {
	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Logout with params: %#v", *e.params)
		}
	}

	afterLogoutCounter := mm_atomic.LoadUint64(&m.afterLogoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogoutMock.defaultExpectation != nil && afterLogoutCounter < 1 {
		if m.LogoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Logout")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Logout with params: %#v", *m.LogoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogout != nil && afterLogoutCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Logout")
	}

	if !m.LogoutMock.invocationsDone() && afterLogoutCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Logout but found %d calls",
			mm_atomic.LoadUint64(&m.LogoutMock.expectedInvocations), afterLogoutCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAccessTokenInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockLoginInspect()

			m.MinimockLogoutInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockLoginDone() &&
		m.MinimockLogoutDone()
}
