// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/8thgencore/microservice-auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// TokenOperationsMock implements mm_tokens.TokenOperations
type TokenOperationsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGenerateAccessToken          func(user model.User) (s1 string, err error)
	funcGenerateAccessTokenOrigin    string
	inspectFuncGenerateAccessToken   func(user model.User)
	afterGenerateAccessTokenCounter  uint64
	beforeGenerateAccessTokenCounter uint64
	GenerateAccessTokenMock          mTokenOperationsMockGenerateAccessToken

	funcGenerateRefreshToken          func(userID string) (s1 string, err error)
	funcGenerateRefreshTokenOrigin    string
	inspectFuncGenerateRefreshToken   func(userID string)
	afterGenerateRefreshTokenCounter  uint64
	beforeGenerateRefreshTokenCounter uint64
	GenerateRefreshTokenMock          mTokenOperationsMockGenerateRefreshToken

	funcVerifyAccessToken          func(tokenStr string) (up1 *model.UserClaims, err error)
	funcVerifyAccessTokenOrigin    string
	inspectFuncVerifyAccessToken   func(tokenStr string)
	afterVerifyAccessTokenCounter  uint64
	beforeVerifyAccessTokenCounter uint64
	VerifyAccessTokenMock          mTokenOperationsMockVerifyAccessToken

	funcVerifyRefreshToken          func(tokenStr string) (rp1 *model.RefreshClaims, err error)
	funcVerifyRefreshTokenOrigin    string
	inspectFuncVerifyRefreshToken   func(tokenStr string)
	afterVerifyRefreshTokenCounter  uint64
	beforeVerifyRefreshTokenCounter uint64
	VerifyRefreshTokenMock          mTokenOperationsMockVerifyRefreshToken
}

// NewTokenOperationsMock returns a mock for mm_tokens.TokenOperations
func NewTokenOperationsMock(t minimock.Tester) *TokenOperationsMock {
	m := &TokenOperationsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateAccessTokenMock = mTokenOperationsMockGenerateAccessToken{mock: m}
	m.GenerateAccessTokenMock.callArgs = []*TokenOperationsMockGenerateAccessTokenParams{}

	m.GenerateRefreshTokenMock = mTokenOperationsMockGenerateRefreshToken{mock: m}
	m.GenerateRefreshTokenMock.callArgs = []*TokenOperationsMockGenerateRefreshTokenParams{}

	m.VerifyAccessTokenMock = mTokenOperationsMockVerifyAccessToken{mock: m}
	m.VerifyAccessTokenMock.callArgs = []*TokenOperationsMockVerifyAccessTokenParams{}

	m.VerifyRefreshTokenMock = mTokenOperationsMockVerifyRefreshToken{mock: m}
	m.VerifyRefreshTokenMock.callArgs = []*TokenOperationsMockVerifyRefreshTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTokenOperationsMockGenerateAccessToken struct {
	optional           bool
	mock               *TokenOperationsMock
	defaultExpectation *TokenOperationsMockGenerateAccessTokenExpectation
	expectations       []*TokenOperationsMockGenerateAccessTokenExpectation

	callArgs []*TokenOperationsMockGenerateAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenOperationsMockGenerateAccessTokenExpectation specifies expectation struct of the TokenOperations.GenerateAccessToken
type TokenOperationsMockGenerateAccessTokenExpectation struct {
	mock               *TokenOperationsMock
	params             *TokenOperationsMockGenerateAccessTokenParams
	paramPtrs          *TokenOperationsMockGenerateAccessTokenParamPtrs
	expectationOrigins TokenOperationsMockGenerateAccessTokenExpectationOrigins
	results            *TokenOperationsMockGenerateAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenOperationsMockGenerateAccessTokenParams contains parameters of the TokenOperations.GenerateAccessToken
type TokenOperationsMockGenerateAccessTokenParams struct {
	user model.User
}

// TokenOperationsMockGenerateAccessTokenParamPtrs contains pointers to parameters of the TokenOperations.GenerateAccessToken
type TokenOperationsMockGenerateAccessTokenParamPtrs struct {
	user *model.User
}

// TokenOperationsMockGenerateAccessTokenResults contains results of the TokenOperations.GenerateAccessToken
type TokenOperationsMockGenerateAccessTokenResults struct {
	s1  string
	err error
}

// TokenOperationsMockGenerateAccessTokenOrigins contains origins of expectations of the TokenOperations.GenerateAccessToken
type TokenOperationsMockGenerateAccessTokenExpectationOrigins struct {
	origin     string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Optional() *mTokenOperationsMockGenerateAccessToken {
	mmGenerateAccessToken.optional = true
	return mmGenerateAccessToken
}

// Expect sets up expected params for TokenOperations.GenerateAccessToken
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Expect(user model.User) *mTokenOperationsMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &TokenOperationsMockGenerateAccessTokenExpectation{}
	}

	if mmGenerateAccessToken.defaultExpectation.paramPtrs != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by ExpectParams functions")
	}

	mmGenerateAccessToken.defaultExpectation.params = &TokenOperationsMockGenerateAccessTokenParams{user}
	mmGenerateAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateAccessToken.expectations {
		if minimock.Equal(e.params, mmGenerateAccessToken.defaultExpectation.params) {
			mmGenerateAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateAccessToken.defaultExpectation.params)
		}
	}

	return mmGenerateAccessToken
}

// ExpectUserParam1 sets up expected param user for TokenOperations.GenerateAccessToken
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) ExpectUserParam1(user model.User) *mTokenOperationsMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &TokenOperationsMockGenerateAccessTokenExpectation{}
	}

	if mmGenerateAccessToken.defaultExpectation.params != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by Expect")
	}

	if mmGenerateAccessToken.defaultExpectation.paramPtrs == nil {
		mmGenerateAccessToken.defaultExpectation.paramPtrs = &TokenOperationsMockGenerateAccessTokenParamPtrs{}
	}
	mmGenerateAccessToken.defaultExpectation.paramPtrs.user = &user
	mmGenerateAccessToken.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmGenerateAccessToken
}

// Inspect accepts an inspector function that has same arguments as the TokenOperations.GenerateAccessToken
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Inspect(f func(user model.User)) *mTokenOperationsMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.inspectFuncGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("Inspect function is already set for TokenOperationsMock.GenerateAccessToken")
	}

	mmGenerateAccessToken.mock.inspectFuncGenerateAccessToken = f

	return mmGenerateAccessToken
}

// Return sets up results that will be returned by TokenOperations.GenerateAccessToken
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Return(s1 string, err error) *TokenOperationsMock {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &TokenOperationsMockGenerateAccessTokenExpectation{mock: mmGenerateAccessToken.mock}
	}
	mmGenerateAccessToken.defaultExpectation.results = &TokenOperationsMockGenerateAccessTokenResults{s1, err}
	mmGenerateAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken.mock
}

// Set uses given function f to mock the TokenOperations.GenerateAccessToken method
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Set(f func(user model.User) (s1 string, err error)) *TokenOperationsMock {
	if mmGenerateAccessToken.defaultExpectation != nil {
		mmGenerateAccessToken.mock.t.Fatalf("Default expectation is already set for the TokenOperations.GenerateAccessToken method")
	}

	if len(mmGenerateAccessToken.expectations) > 0 {
		mmGenerateAccessToken.mock.t.Fatalf("Some expectations are already set for the TokenOperations.GenerateAccessToken method")
	}

	mmGenerateAccessToken.mock.funcGenerateAccessToken = f
	mmGenerateAccessToken.mock.funcGenerateAccessTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken.mock
}

// When sets expectation for the TokenOperations.GenerateAccessToken which will trigger the result defined by the following
// Then helper
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) When(user model.User) *TokenOperationsMockGenerateAccessTokenExpectation {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("TokenOperationsMock.GenerateAccessToken mock is already set by Set")
	}

	expectation := &TokenOperationsMockGenerateAccessTokenExpectation{
		mock:               mmGenerateAccessToken.mock,
		params:             &TokenOperationsMockGenerateAccessTokenParams{user},
		expectationOrigins: TokenOperationsMockGenerateAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateAccessToken.expectations = append(mmGenerateAccessToken.expectations, expectation)
	return expectation
}

// Then sets up TokenOperations.GenerateAccessToken return parameters for the expectation previously defined by the When method
func (e *TokenOperationsMockGenerateAccessTokenExpectation) Then(s1 string, err error) *TokenOperationsMock {
	e.results = &TokenOperationsMockGenerateAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times TokenOperations.GenerateAccessToken should be invoked
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Times(n uint64) *mTokenOperationsMockGenerateAccessToken {
	if n == 0 {
		mmGenerateAccessToken.mock.t.Fatalf("Times of TokenOperationsMock.GenerateAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateAccessToken.expectedInvocations, n)
	mmGenerateAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken
}

func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) invocationsDone() bool {
	if len(mmGenerateAccessToken.expectations) == 0 && mmGenerateAccessToken.defaultExpectation == nil && mmGenerateAccessToken.mock.funcGenerateAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateAccessToken.mock.afterGenerateAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateAccessToken implements mm_tokens.TokenOperations
func (mmGenerateAccessToken *TokenOperationsMock) GenerateAccessToken(user model.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateAccessToken.beforeGenerateAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateAccessToken.afterGenerateAccessTokenCounter, 1)

	mmGenerateAccessToken.t.Helper()

	if mmGenerateAccessToken.inspectFuncGenerateAccessToken != nil {
		mmGenerateAccessToken.inspectFuncGenerateAccessToken(user)
	}

	mm_params := TokenOperationsMockGenerateAccessTokenParams{user}

	// Record call args
	mmGenerateAccessToken.GenerateAccessTokenMock.mutex.Lock()
	mmGenerateAccessToken.GenerateAccessTokenMock.callArgs = append(mmGenerateAccessToken.GenerateAccessTokenMock.callArgs, &mm_params)
	mmGenerateAccessToken.GenerateAccessTokenMock.mutex.Unlock()

	for _, e := range mmGenerateAccessToken.GenerateAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenOperationsMockGenerateAccessTokenParams{user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmGenerateAccessToken.t.Errorf("TokenOperationsMock.GenerateAccessToken got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateAccessToken.t.Errorf("TokenOperationsMock.GenerateAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateAccessToken.t.Fatal("No results are set for the TokenOperationsMock.GenerateAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateAccessToken.funcGenerateAccessToken != nil {
		return mmGenerateAccessToken.funcGenerateAccessToken(user)
	}
	mmGenerateAccessToken.t.Fatalf("Unexpected call to TokenOperationsMock.GenerateAccessToken. %v", user)
	return
}

// GenerateAccessTokenAfterCounter returns a count of finished TokenOperationsMock.GenerateAccessToken invocations
func (mmGenerateAccessToken *TokenOperationsMock) GenerateAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateAccessToken.afterGenerateAccessTokenCounter)
}

// GenerateAccessTokenBeforeCounter returns a count of TokenOperationsMock.GenerateAccessToken invocations
func (mmGenerateAccessToken *TokenOperationsMock) GenerateAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateAccessToken.beforeGenerateAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenOperationsMock.GenerateAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateAccessToken *mTokenOperationsMockGenerateAccessToken) Calls() []*TokenOperationsMockGenerateAccessTokenParams {
	mmGenerateAccessToken.mutex.RLock()

	argCopy := make([]*TokenOperationsMockGenerateAccessTokenParams, len(mmGenerateAccessToken.callArgs))
	copy(argCopy, mmGenerateAccessToken.callArgs)

	mmGenerateAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateAccessTokenDone returns true if the count of the GenerateAccessToken invocations corresponds
// the number of defined expectations
func (m *TokenOperationsMock) MinimockGenerateAccessTokenDone() bool {
	if m.GenerateAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateAccessTokenMock.invocationsDone()
}

// MinimockGenerateAccessTokenInspect logs each unmet expectation
func (m *TokenOperationsMock) MinimockGenerateAccessTokenInspect() {
	for _, e := range m.GenerateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateAccessTokenMock.defaultExpectation != nil && afterGenerateAccessTokenCounter < 1 {
		if m.GenerateAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateAccessToken at\n%s", m.GenerateAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateAccessToken at\n%s with params: %#v", m.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateAccessToken != nil && afterGenerateAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenOperationsMock.GenerateAccessToken at\n%s", m.funcGenerateAccessTokenOrigin)
	}

	if !m.GenerateAccessTokenMock.invocationsDone() && afterGenerateAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenOperationsMock.GenerateAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateAccessTokenMock.expectedInvocations), m.GenerateAccessTokenMock.expectedInvocationsOrigin, afterGenerateAccessTokenCounter)
	}
}

type mTokenOperationsMockGenerateRefreshToken struct {
	optional           bool
	mock               *TokenOperationsMock
	defaultExpectation *TokenOperationsMockGenerateRefreshTokenExpectation
	expectations       []*TokenOperationsMockGenerateRefreshTokenExpectation

	callArgs []*TokenOperationsMockGenerateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenOperationsMockGenerateRefreshTokenExpectation specifies expectation struct of the TokenOperations.GenerateRefreshToken
type TokenOperationsMockGenerateRefreshTokenExpectation struct {
	mock               *TokenOperationsMock
	params             *TokenOperationsMockGenerateRefreshTokenParams
	paramPtrs          *TokenOperationsMockGenerateRefreshTokenParamPtrs
	expectationOrigins TokenOperationsMockGenerateRefreshTokenExpectationOrigins
	results            *TokenOperationsMockGenerateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenOperationsMockGenerateRefreshTokenParams contains parameters of the TokenOperations.GenerateRefreshToken
type TokenOperationsMockGenerateRefreshTokenParams struct {
	userID string
}

// TokenOperationsMockGenerateRefreshTokenParamPtrs contains pointers to parameters of the TokenOperations.GenerateRefreshToken
type TokenOperationsMockGenerateRefreshTokenParamPtrs struct {
	userID *string
}

// TokenOperationsMockGenerateRefreshTokenResults contains results of the TokenOperations.GenerateRefreshToken
type TokenOperationsMockGenerateRefreshTokenResults struct {
	s1  string
	err error
}

// TokenOperationsMockGenerateRefreshTokenOrigins contains origins of expectations of the TokenOperations.GenerateRefreshToken
type TokenOperationsMockGenerateRefreshTokenExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Optional() *mTokenOperationsMockGenerateRefreshToken {
	mmGenerateRefreshToken.optional = true
	return mmGenerateRefreshToken
}

// Expect sets up expected params for TokenOperations.GenerateRefreshToken
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Expect(userID string) *mTokenOperationsMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &TokenOperationsMockGenerateRefreshTokenExpectation{}
	}

	if mmGenerateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by ExpectParams functions")
	}

	mmGenerateRefreshToken.defaultExpectation.params = &TokenOperationsMockGenerateRefreshTokenParams{userID}
	mmGenerateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateRefreshToken.expectations {
		if minimock.Equal(e.params, mmGenerateRefreshToken.defaultExpectation.params) {
			mmGenerateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateRefreshToken.defaultExpectation.params)
		}
	}

	return mmGenerateRefreshToken
}

// ExpectUserIDParam1 sets up expected param userID for TokenOperations.GenerateRefreshToken
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) ExpectUserIDParam1(userID string) *mTokenOperationsMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &TokenOperationsMockGenerateRefreshTokenExpectation{}
	}

	if mmGenerateRefreshToken.defaultExpectation.params != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by Expect")
	}

	if mmGenerateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGenerateRefreshToken.defaultExpectation.paramPtrs = &TokenOperationsMockGenerateRefreshTokenParamPtrs{}
	}
	mmGenerateRefreshToken.defaultExpectation.paramPtrs.userID = &userID
	mmGenerateRefreshToken.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGenerateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the TokenOperations.GenerateRefreshToken
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Inspect(f func(userID string)) *mTokenOperationsMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.inspectFuncGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("Inspect function is already set for TokenOperationsMock.GenerateRefreshToken")
	}

	mmGenerateRefreshToken.mock.inspectFuncGenerateRefreshToken = f

	return mmGenerateRefreshToken
}

// Return sets up results that will be returned by TokenOperations.GenerateRefreshToken
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Return(s1 string, err error) *TokenOperationsMock {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &TokenOperationsMockGenerateRefreshTokenExpectation{mock: mmGenerateRefreshToken.mock}
	}
	mmGenerateRefreshToken.defaultExpectation.results = &TokenOperationsMockGenerateRefreshTokenResults{s1, err}
	mmGenerateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken.mock
}

// Set uses given function f to mock the TokenOperations.GenerateRefreshToken method
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Set(f func(userID string) (s1 string, err error)) *TokenOperationsMock {
	if mmGenerateRefreshToken.defaultExpectation != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("Default expectation is already set for the TokenOperations.GenerateRefreshToken method")
	}

	if len(mmGenerateRefreshToken.expectations) > 0 {
		mmGenerateRefreshToken.mock.t.Fatalf("Some expectations are already set for the TokenOperations.GenerateRefreshToken method")
	}

	mmGenerateRefreshToken.mock.funcGenerateRefreshToken = f
	mmGenerateRefreshToken.mock.funcGenerateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken.mock
}

// When sets expectation for the TokenOperations.GenerateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) When(userID string) *TokenOperationsMockGenerateRefreshTokenExpectation {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("TokenOperationsMock.GenerateRefreshToken mock is already set by Set")
	}

	expectation := &TokenOperationsMockGenerateRefreshTokenExpectation{
		mock:               mmGenerateRefreshToken.mock,
		params:             &TokenOperationsMockGenerateRefreshTokenParams{userID},
		expectationOrigins: TokenOperationsMockGenerateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateRefreshToken.expectations = append(mmGenerateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up TokenOperations.GenerateRefreshToken return parameters for the expectation previously defined by the When method
func (e *TokenOperationsMockGenerateRefreshTokenExpectation) Then(s1 string, err error) *TokenOperationsMock {
	e.results = &TokenOperationsMockGenerateRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times TokenOperations.GenerateRefreshToken should be invoked
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Times(n uint64) *mTokenOperationsMockGenerateRefreshToken {
	if n == 0 {
		mmGenerateRefreshToken.mock.t.Fatalf("Times of TokenOperationsMock.GenerateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateRefreshToken.expectedInvocations, n)
	mmGenerateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken
}

func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) invocationsDone() bool {
	if len(mmGenerateRefreshToken.expectations) == 0 && mmGenerateRefreshToken.defaultExpectation == nil && mmGenerateRefreshToken.mock.funcGenerateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateRefreshToken.mock.afterGenerateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateRefreshToken implements mm_tokens.TokenOperations
func (mmGenerateRefreshToken *TokenOperationsMock) GenerateRefreshToken(userID string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateRefreshToken.beforeGenerateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateRefreshToken.afterGenerateRefreshTokenCounter, 1)

	mmGenerateRefreshToken.t.Helper()

	if mmGenerateRefreshToken.inspectFuncGenerateRefreshToken != nil {
		mmGenerateRefreshToken.inspectFuncGenerateRefreshToken(userID)
	}

	mm_params := TokenOperationsMockGenerateRefreshTokenParams{userID}

	// Record call args
	mmGenerateRefreshToken.GenerateRefreshTokenMock.mutex.Lock()
	mmGenerateRefreshToken.GenerateRefreshTokenMock.callArgs = append(mmGenerateRefreshToken.GenerateRefreshTokenMock.callArgs, &mm_params)
	mmGenerateRefreshToken.GenerateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGenerateRefreshToken.GenerateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenOperationsMockGenerateRefreshTokenParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGenerateRefreshToken.t.Errorf("TokenOperationsMock.GenerateRefreshToken got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateRefreshToken.t.Errorf("TokenOperationsMock.GenerateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateRefreshToken.t.Fatal("No results are set for the TokenOperationsMock.GenerateRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateRefreshToken.funcGenerateRefreshToken != nil {
		return mmGenerateRefreshToken.funcGenerateRefreshToken(userID)
	}
	mmGenerateRefreshToken.t.Fatalf("Unexpected call to TokenOperationsMock.GenerateRefreshToken. %v", userID)
	return
}

// GenerateRefreshTokenAfterCounter returns a count of finished TokenOperationsMock.GenerateRefreshToken invocations
func (mmGenerateRefreshToken *TokenOperationsMock) GenerateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateRefreshToken.afterGenerateRefreshTokenCounter)
}

// GenerateRefreshTokenBeforeCounter returns a count of TokenOperationsMock.GenerateRefreshToken invocations
func (mmGenerateRefreshToken *TokenOperationsMock) GenerateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateRefreshToken.beforeGenerateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenOperationsMock.GenerateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateRefreshToken *mTokenOperationsMockGenerateRefreshToken) Calls() []*TokenOperationsMockGenerateRefreshTokenParams {
	mmGenerateRefreshToken.mutex.RLock()

	argCopy := make([]*TokenOperationsMockGenerateRefreshTokenParams, len(mmGenerateRefreshToken.callArgs))
	copy(argCopy, mmGenerateRefreshToken.callArgs)

	mmGenerateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateRefreshTokenDone returns true if the count of the GenerateRefreshToken invocations corresponds
// the number of defined expectations
func (m *TokenOperationsMock) MinimockGenerateRefreshTokenDone() bool {
	if m.GenerateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateRefreshTokenMock.invocationsDone()
}

// MinimockGenerateRefreshTokenInspect logs each unmet expectation
func (m *TokenOperationsMock) MinimockGenerateRefreshTokenInspect() {
	for _, e := range m.GenerateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateRefreshTokenMock.defaultExpectation != nil && afterGenerateRefreshTokenCounter < 1 {
		if m.GenerateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateRefreshToken at\n%s", m.GenerateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenOperationsMock.GenerateRefreshToken at\n%s with params: %#v", m.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateRefreshToken != nil && afterGenerateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenOperationsMock.GenerateRefreshToken at\n%s", m.funcGenerateRefreshTokenOrigin)
	}

	if !m.GenerateRefreshTokenMock.invocationsDone() && afterGenerateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenOperationsMock.GenerateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateRefreshTokenMock.expectedInvocations), m.GenerateRefreshTokenMock.expectedInvocationsOrigin, afterGenerateRefreshTokenCounter)
	}
}

type mTokenOperationsMockVerifyAccessToken struct {
	optional           bool
	mock               *TokenOperationsMock
	defaultExpectation *TokenOperationsMockVerifyAccessTokenExpectation
	expectations       []*TokenOperationsMockVerifyAccessTokenExpectation

	callArgs []*TokenOperationsMockVerifyAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenOperationsMockVerifyAccessTokenExpectation specifies expectation struct of the TokenOperations.VerifyAccessToken
type TokenOperationsMockVerifyAccessTokenExpectation struct {
	mock               *TokenOperationsMock
	params             *TokenOperationsMockVerifyAccessTokenParams
	paramPtrs          *TokenOperationsMockVerifyAccessTokenParamPtrs
	expectationOrigins TokenOperationsMockVerifyAccessTokenExpectationOrigins
	results            *TokenOperationsMockVerifyAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenOperationsMockVerifyAccessTokenParams contains parameters of the TokenOperations.VerifyAccessToken
type TokenOperationsMockVerifyAccessTokenParams struct {
	tokenStr string
}

// TokenOperationsMockVerifyAccessTokenParamPtrs contains pointers to parameters of the TokenOperations.VerifyAccessToken
type TokenOperationsMockVerifyAccessTokenParamPtrs struct {
	tokenStr *string
}

// TokenOperationsMockVerifyAccessTokenResults contains results of the TokenOperations.VerifyAccessToken
type TokenOperationsMockVerifyAccessTokenResults struct {
	up1 *model.UserClaims
	err error
}

// TokenOperationsMockVerifyAccessTokenOrigins contains origins of expectations of the TokenOperations.VerifyAccessToken
type TokenOperationsMockVerifyAccessTokenExpectationOrigins struct {
	origin         string
	originTokenStr string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Optional() *mTokenOperationsMockVerifyAccessToken {
	mmVerifyAccessToken.optional = true
	return mmVerifyAccessToken
}

// Expect sets up expected params for TokenOperations.VerifyAccessToken
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Expect(tokenStr string) *mTokenOperationsMockVerifyAccessToken {
	if mmVerifyAccessToken.mock.funcVerifyAccessToken != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by Set")
	}

	if mmVerifyAccessToken.defaultExpectation == nil {
		mmVerifyAccessToken.defaultExpectation = &TokenOperationsMockVerifyAccessTokenExpectation{}
	}

	if mmVerifyAccessToken.defaultExpectation.paramPtrs != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by ExpectParams functions")
	}

	mmVerifyAccessToken.defaultExpectation.params = &TokenOperationsMockVerifyAccessTokenParams{tokenStr}
	mmVerifyAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyAccessToken.expectations {
		if minimock.Equal(e.params, mmVerifyAccessToken.defaultExpectation.params) {
			mmVerifyAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyAccessToken.defaultExpectation.params)
		}
	}

	return mmVerifyAccessToken
}

// ExpectTokenStrParam1 sets up expected param tokenStr for TokenOperations.VerifyAccessToken
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) ExpectTokenStrParam1(tokenStr string) *mTokenOperationsMockVerifyAccessToken {
	if mmVerifyAccessToken.mock.funcVerifyAccessToken != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by Set")
	}

	if mmVerifyAccessToken.defaultExpectation == nil {
		mmVerifyAccessToken.defaultExpectation = &TokenOperationsMockVerifyAccessTokenExpectation{}
	}

	if mmVerifyAccessToken.defaultExpectation.params != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by Expect")
	}

	if mmVerifyAccessToken.defaultExpectation.paramPtrs == nil {
		mmVerifyAccessToken.defaultExpectation.paramPtrs = &TokenOperationsMockVerifyAccessTokenParamPtrs{}
	}
	mmVerifyAccessToken.defaultExpectation.paramPtrs.tokenStr = &tokenStr
	mmVerifyAccessToken.defaultExpectation.expectationOrigins.originTokenStr = minimock.CallerInfo(1)

	return mmVerifyAccessToken
}

// Inspect accepts an inspector function that has same arguments as the TokenOperations.VerifyAccessToken
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Inspect(f func(tokenStr string)) *mTokenOperationsMockVerifyAccessToken {
	if mmVerifyAccessToken.mock.inspectFuncVerifyAccessToken != nil {
		mmVerifyAccessToken.mock.t.Fatalf("Inspect function is already set for TokenOperationsMock.VerifyAccessToken")
	}

	mmVerifyAccessToken.mock.inspectFuncVerifyAccessToken = f

	return mmVerifyAccessToken
}

// Return sets up results that will be returned by TokenOperations.VerifyAccessToken
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Return(up1 *model.UserClaims, err error) *TokenOperationsMock {
	if mmVerifyAccessToken.mock.funcVerifyAccessToken != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by Set")
	}

	if mmVerifyAccessToken.defaultExpectation == nil {
		mmVerifyAccessToken.defaultExpectation = &TokenOperationsMockVerifyAccessTokenExpectation{mock: mmVerifyAccessToken.mock}
	}
	mmVerifyAccessToken.defaultExpectation.results = &TokenOperationsMockVerifyAccessTokenResults{up1, err}
	mmVerifyAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyAccessToken.mock
}

// Set uses given function f to mock the TokenOperations.VerifyAccessToken method
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Set(f func(tokenStr string) (up1 *model.UserClaims, err error)) *TokenOperationsMock {
	if mmVerifyAccessToken.defaultExpectation != nil {
		mmVerifyAccessToken.mock.t.Fatalf("Default expectation is already set for the TokenOperations.VerifyAccessToken method")
	}

	if len(mmVerifyAccessToken.expectations) > 0 {
		mmVerifyAccessToken.mock.t.Fatalf("Some expectations are already set for the TokenOperations.VerifyAccessToken method")
	}

	mmVerifyAccessToken.mock.funcVerifyAccessToken = f
	mmVerifyAccessToken.mock.funcVerifyAccessTokenOrigin = minimock.CallerInfo(1)
	return mmVerifyAccessToken.mock
}

// When sets expectation for the TokenOperations.VerifyAccessToken which will trigger the result defined by the following
// Then helper
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) When(tokenStr string) *TokenOperationsMockVerifyAccessTokenExpectation {
	if mmVerifyAccessToken.mock.funcVerifyAccessToken != nil {
		mmVerifyAccessToken.mock.t.Fatalf("TokenOperationsMock.VerifyAccessToken mock is already set by Set")
	}

	expectation := &TokenOperationsMockVerifyAccessTokenExpectation{
		mock:               mmVerifyAccessToken.mock,
		params:             &TokenOperationsMockVerifyAccessTokenParams{tokenStr},
		expectationOrigins: TokenOperationsMockVerifyAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyAccessToken.expectations = append(mmVerifyAccessToken.expectations, expectation)
	return expectation
}

// Then sets up TokenOperations.VerifyAccessToken return parameters for the expectation previously defined by the When method
func (e *TokenOperationsMockVerifyAccessTokenExpectation) Then(up1 *model.UserClaims, err error) *TokenOperationsMock {
	e.results = &TokenOperationsMockVerifyAccessTokenResults{up1, err}
	return e.mock
}

// Times sets number of times TokenOperations.VerifyAccessToken should be invoked
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Times(n uint64) *mTokenOperationsMockVerifyAccessToken {
	if n == 0 {
		mmVerifyAccessToken.mock.t.Fatalf("Times of TokenOperationsMock.VerifyAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyAccessToken.expectedInvocations, n)
	mmVerifyAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyAccessToken
}

func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) invocationsDone() bool {
	if len(mmVerifyAccessToken.expectations) == 0 && mmVerifyAccessToken.defaultExpectation == nil && mmVerifyAccessToken.mock.funcVerifyAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyAccessToken.mock.afterVerifyAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyAccessToken implements mm_tokens.TokenOperations
func (mmVerifyAccessToken *TokenOperationsMock) VerifyAccessToken(tokenStr string) (up1 *model.UserClaims, err error) {
	mm_atomic.AddUint64(&mmVerifyAccessToken.beforeVerifyAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyAccessToken.afterVerifyAccessTokenCounter, 1)

	mmVerifyAccessToken.t.Helper()

	if mmVerifyAccessToken.inspectFuncVerifyAccessToken != nil {
		mmVerifyAccessToken.inspectFuncVerifyAccessToken(tokenStr)
	}

	mm_params := TokenOperationsMockVerifyAccessTokenParams{tokenStr}

	// Record call args
	mmVerifyAccessToken.VerifyAccessTokenMock.mutex.Lock()
	mmVerifyAccessToken.VerifyAccessTokenMock.callArgs = append(mmVerifyAccessToken.VerifyAccessTokenMock.callArgs, &mm_params)
	mmVerifyAccessToken.VerifyAccessTokenMock.mutex.Unlock()

	for _, e := range mmVerifyAccessToken.VerifyAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenOperationsMockVerifyAccessTokenParams{tokenStr}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tokenStr != nil && !minimock.Equal(*mm_want_ptrs.tokenStr, mm_got.tokenStr) {
				mmVerifyAccessToken.t.Errorf("TokenOperationsMock.VerifyAccessToken got unexpected parameter tokenStr, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.expectationOrigins.originTokenStr, *mm_want_ptrs.tokenStr, mm_got.tokenStr, minimock.Diff(*mm_want_ptrs.tokenStr, mm_got.tokenStr))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyAccessToken.t.Errorf("TokenOperationsMock.VerifyAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyAccessToken.VerifyAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyAccessToken.t.Fatal("No results are set for the TokenOperationsMock.VerifyAccessToken")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmVerifyAccessToken.funcVerifyAccessToken != nil {
		return mmVerifyAccessToken.funcVerifyAccessToken(tokenStr)
	}
	mmVerifyAccessToken.t.Fatalf("Unexpected call to TokenOperationsMock.VerifyAccessToken. %v", tokenStr)
	return
}

// VerifyAccessTokenAfterCounter returns a count of finished TokenOperationsMock.VerifyAccessToken invocations
func (mmVerifyAccessToken *TokenOperationsMock) VerifyAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyAccessToken.afterVerifyAccessTokenCounter)
}

// VerifyAccessTokenBeforeCounter returns a count of TokenOperationsMock.VerifyAccessToken invocations
func (mmVerifyAccessToken *TokenOperationsMock) VerifyAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyAccessToken.beforeVerifyAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenOperationsMock.VerifyAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyAccessToken *mTokenOperationsMockVerifyAccessToken) Calls() []*TokenOperationsMockVerifyAccessTokenParams {
	mmVerifyAccessToken.mutex.RLock()

	argCopy := make([]*TokenOperationsMockVerifyAccessTokenParams, len(mmVerifyAccessToken.callArgs))
	copy(argCopy, mmVerifyAccessToken.callArgs)

	mmVerifyAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyAccessTokenDone returns true if the count of the VerifyAccessToken invocations corresponds
// the number of defined expectations
func (m *TokenOperationsMock) MinimockVerifyAccessTokenDone() bool {
	if m.VerifyAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyAccessTokenMock.invocationsDone()
}

// MinimockVerifyAccessTokenInspect logs each unmet expectation
func (m *TokenOperationsMock) MinimockVerifyAccessTokenInspect() {
	for _, e := range m.VerifyAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyAccessTokenCounter := mm_atomic.LoadUint64(&m.afterVerifyAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyAccessTokenMock.defaultExpectation != nil && afterVerifyAccessTokenCounter < 1 {
		if m.VerifyAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyAccessToken at\n%s", m.VerifyAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyAccessToken at\n%s with params: %#v", m.VerifyAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.VerifyAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyAccessToken != nil && afterVerifyAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenOperationsMock.VerifyAccessToken at\n%s", m.funcVerifyAccessTokenOrigin)
	}

	if !m.VerifyAccessTokenMock.invocationsDone() && afterVerifyAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenOperationsMock.VerifyAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyAccessTokenMock.expectedInvocations), m.VerifyAccessTokenMock.expectedInvocationsOrigin, afterVerifyAccessTokenCounter)
	}
}

type mTokenOperationsMockVerifyRefreshToken struct {
	optional           bool
	mock               *TokenOperationsMock
	defaultExpectation *TokenOperationsMockVerifyRefreshTokenExpectation
	expectations       []*TokenOperationsMockVerifyRefreshTokenExpectation

	callArgs []*TokenOperationsMockVerifyRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenOperationsMockVerifyRefreshTokenExpectation specifies expectation struct of the TokenOperations.VerifyRefreshToken
type TokenOperationsMockVerifyRefreshTokenExpectation struct {
	mock               *TokenOperationsMock
	params             *TokenOperationsMockVerifyRefreshTokenParams
	paramPtrs          *TokenOperationsMockVerifyRefreshTokenParamPtrs
	expectationOrigins TokenOperationsMockVerifyRefreshTokenExpectationOrigins
	results            *TokenOperationsMockVerifyRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenOperationsMockVerifyRefreshTokenParams contains parameters of the TokenOperations.VerifyRefreshToken
type TokenOperationsMockVerifyRefreshTokenParams struct {
	tokenStr string
}

// TokenOperationsMockVerifyRefreshTokenParamPtrs contains pointers to parameters of the TokenOperations.VerifyRefreshToken
type TokenOperationsMockVerifyRefreshTokenParamPtrs struct {
	tokenStr *string
}

// TokenOperationsMockVerifyRefreshTokenResults contains results of the TokenOperations.VerifyRefreshToken
type TokenOperationsMockVerifyRefreshTokenResults struct {
	rp1 *model.RefreshClaims
	err error
}

// TokenOperationsMockVerifyRefreshTokenOrigins contains origins of expectations of the TokenOperations.VerifyRefreshToken
type TokenOperationsMockVerifyRefreshTokenExpectationOrigins struct {
	origin         string
	originTokenStr string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Optional() *mTokenOperationsMockVerifyRefreshToken {
	mmVerifyRefreshToken.optional = true
	return mmVerifyRefreshToken
}

// Expect sets up expected params for TokenOperations.VerifyRefreshToken
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Expect(tokenStr string) *mTokenOperationsMockVerifyRefreshToken {
	if mmVerifyRefreshToken.mock.funcVerifyRefreshToken != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by Set")
	}

	if mmVerifyRefreshToken.defaultExpectation == nil {
		mmVerifyRefreshToken.defaultExpectation = &TokenOperationsMockVerifyRefreshTokenExpectation{}
	}

	if mmVerifyRefreshToken.defaultExpectation.paramPtrs != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by ExpectParams functions")
	}

	mmVerifyRefreshToken.defaultExpectation.params = &TokenOperationsMockVerifyRefreshTokenParams{tokenStr}
	mmVerifyRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyRefreshToken.expectations {
		if minimock.Equal(e.params, mmVerifyRefreshToken.defaultExpectation.params) {
			mmVerifyRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyRefreshToken.defaultExpectation.params)
		}
	}

	return mmVerifyRefreshToken
}

// ExpectTokenStrParam1 sets up expected param tokenStr for TokenOperations.VerifyRefreshToken
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) ExpectTokenStrParam1(tokenStr string) *mTokenOperationsMockVerifyRefreshToken {
	if mmVerifyRefreshToken.mock.funcVerifyRefreshToken != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by Set")
	}

	if mmVerifyRefreshToken.defaultExpectation == nil {
		mmVerifyRefreshToken.defaultExpectation = &TokenOperationsMockVerifyRefreshTokenExpectation{}
	}

	if mmVerifyRefreshToken.defaultExpectation.params != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by Expect")
	}

	if mmVerifyRefreshToken.defaultExpectation.paramPtrs == nil {
		mmVerifyRefreshToken.defaultExpectation.paramPtrs = &TokenOperationsMockVerifyRefreshTokenParamPtrs{}
	}
	mmVerifyRefreshToken.defaultExpectation.paramPtrs.tokenStr = &tokenStr
	mmVerifyRefreshToken.defaultExpectation.expectationOrigins.originTokenStr = minimock.CallerInfo(1)

	return mmVerifyRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the TokenOperations.VerifyRefreshToken
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Inspect(f func(tokenStr string)) *mTokenOperationsMockVerifyRefreshToken {
	if mmVerifyRefreshToken.mock.inspectFuncVerifyRefreshToken != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("Inspect function is already set for TokenOperationsMock.VerifyRefreshToken")
	}

	mmVerifyRefreshToken.mock.inspectFuncVerifyRefreshToken = f

	return mmVerifyRefreshToken
}

// Return sets up results that will be returned by TokenOperations.VerifyRefreshToken
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Return(rp1 *model.RefreshClaims, err error) *TokenOperationsMock {
	if mmVerifyRefreshToken.mock.funcVerifyRefreshToken != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by Set")
	}

	if mmVerifyRefreshToken.defaultExpectation == nil {
		mmVerifyRefreshToken.defaultExpectation = &TokenOperationsMockVerifyRefreshTokenExpectation{mock: mmVerifyRefreshToken.mock}
	}
	mmVerifyRefreshToken.defaultExpectation.results = &TokenOperationsMockVerifyRefreshTokenResults{rp1, err}
	mmVerifyRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyRefreshToken.mock
}

// Set uses given function f to mock the TokenOperations.VerifyRefreshToken method
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Set(f func(tokenStr string) (rp1 *model.RefreshClaims, err error)) *TokenOperationsMock {
	if mmVerifyRefreshToken.defaultExpectation != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("Default expectation is already set for the TokenOperations.VerifyRefreshToken method")
	}

	if len(mmVerifyRefreshToken.expectations) > 0 {
		mmVerifyRefreshToken.mock.t.Fatalf("Some expectations are already set for the TokenOperations.VerifyRefreshToken method")
	}

	mmVerifyRefreshToken.mock.funcVerifyRefreshToken = f
	mmVerifyRefreshToken.mock.funcVerifyRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmVerifyRefreshToken.mock
}

// When sets expectation for the TokenOperations.VerifyRefreshToken which will trigger the result defined by the following
// Then helper
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) When(tokenStr string) *TokenOperationsMockVerifyRefreshTokenExpectation {
	if mmVerifyRefreshToken.mock.funcVerifyRefreshToken != nil {
		mmVerifyRefreshToken.mock.t.Fatalf("TokenOperationsMock.VerifyRefreshToken mock is already set by Set")
	}

	expectation := &TokenOperationsMockVerifyRefreshTokenExpectation{
		mock:               mmVerifyRefreshToken.mock,
		params:             &TokenOperationsMockVerifyRefreshTokenParams{tokenStr},
		expectationOrigins: TokenOperationsMockVerifyRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyRefreshToken.expectations = append(mmVerifyRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up TokenOperations.VerifyRefreshToken return parameters for the expectation previously defined by the When method
func (e *TokenOperationsMockVerifyRefreshTokenExpectation) Then(rp1 *model.RefreshClaims, err error) *TokenOperationsMock {
	e.results = &TokenOperationsMockVerifyRefreshTokenResults{rp1, err}
	return e.mock
}

// Times sets number of times TokenOperations.VerifyRefreshToken should be invoked
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Times(n uint64) *mTokenOperationsMockVerifyRefreshToken {
	if n == 0 {
		mmVerifyRefreshToken.mock.t.Fatalf("Times of TokenOperationsMock.VerifyRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyRefreshToken.expectedInvocations, n)
	mmVerifyRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyRefreshToken
}

func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) invocationsDone() bool {
	if len(mmVerifyRefreshToken.expectations) == 0 && mmVerifyRefreshToken.defaultExpectation == nil && mmVerifyRefreshToken.mock.funcVerifyRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyRefreshToken.mock.afterVerifyRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyRefreshToken implements mm_tokens.TokenOperations
func (mmVerifyRefreshToken *TokenOperationsMock) VerifyRefreshToken(tokenStr string) (rp1 *model.RefreshClaims, err error) {
	mm_atomic.AddUint64(&mmVerifyRefreshToken.beforeVerifyRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyRefreshToken.afterVerifyRefreshTokenCounter, 1)

	mmVerifyRefreshToken.t.Helper()

	if mmVerifyRefreshToken.inspectFuncVerifyRefreshToken != nil {
		mmVerifyRefreshToken.inspectFuncVerifyRefreshToken(tokenStr)
	}

	mm_params := TokenOperationsMockVerifyRefreshTokenParams{tokenStr}

	// Record call args
	mmVerifyRefreshToken.VerifyRefreshTokenMock.mutex.Lock()
	mmVerifyRefreshToken.VerifyRefreshTokenMock.callArgs = append(mmVerifyRefreshToken.VerifyRefreshTokenMock.callArgs, &mm_params)
	mmVerifyRefreshToken.VerifyRefreshTokenMock.mutex.Unlock()

	for _, e := range mmVerifyRefreshToken.VerifyRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenOperationsMockVerifyRefreshTokenParams{tokenStr}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tokenStr != nil && !minimock.Equal(*mm_want_ptrs.tokenStr, mm_got.tokenStr) {
				mmVerifyRefreshToken.t.Errorf("TokenOperationsMock.VerifyRefreshToken got unexpected parameter tokenStr, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.expectationOrigins.originTokenStr, *mm_want_ptrs.tokenStr, mm_got.tokenStr, minimock.Diff(*mm_want_ptrs.tokenStr, mm_got.tokenStr))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyRefreshToken.t.Errorf("TokenOperationsMock.VerifyRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyRefreshToken.VerifyRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyRefreshToken.t.Fatal("No results are set for the TokenOperationsMock.VerifyRefreshToken")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmVerifyRefreshToken.funcVerifyRefreshToken != nil {
		return mmVerifyRefreshToken.funcVerifyRefreshToken(tokenStr)
	}
	mmVerifyRefreshToken.t.Fatalf("Unexpected call to TokenOperationsMock.VerifyRefreshToken. %v", tokenStr)
	return
}

// VerifyRefreshTokenAfterCounter returns a count of finished TokenOperationsMock.VerifyRefreshToken invocations
func (mmVerifyRefreshToken *TokenOperationsMock) VerifyRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyRefreshToken.afterVerifyRefreshTokenCounter)
}

// VerifyRefreshTokenBeforeCounter returns a count of TokenOperationsMock.VerifyRefreshToken invocations
func (mmVerifyRefreshToken *TokenOperationsMock) VerifyRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyRefreshToken.beforeVerifyRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenOperationsMock.VerifyRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyRefreshToken *mTokenOperationsMockVerifyRefreshToken) Calls() []*TokenOperationsMockVerifyRefreshTokenParams {
	mmVerifyRefreshToken.mutex.RLock()

	argCopy := make([]*TokenOperationsMockVerifyRefreshTokenParams, len(mmVerifyRefreshToken.callArgs))
	copy(argCopy, mmVerifyRefreshToken.callArgs)

	mmVerifyRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyRefreshTokenDone returns true if the count of the VerifyRefreshToken invocations corresponds
// the number of defined expectations
func (m *TokenOperationsMock) MinimockVerifyRefreshTokenDone() bool {
	if m.VerifyRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyRefreshTokenMock.invocationsDone()
}

// MinimockVerifyRefreshTokenInspect logs each unmet expectation
func (m *TokenOperationsMock) MinimockVerifyRefreshTokenInspect() {
	for _, e := range m.VerifyRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterVerifyRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyRefreshTokenMock.defaultExpectation != nil && afterVerifyRefreshTokenCounter < 1 {
		if m.VerifyRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyRefreshToken at\n%s", m.VerifyRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenOperationsMock.VerifyRefreshToken at\n%s with params: %#v", m.VerifyRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.VerifyRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyRefreshToken != nil && afterVerifyRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenOperationsMock.VerifyRefreshToken at\n%s", m.funcVerifyRefreshTokenOrigin)
	}

	if !m.VerifyRefreshTokenMock.invocationsDone() && afterVerifyRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenOperationsMock.VerifyRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyRefreshTokenMock.expectedInvocations), m.VerifyRefreshTokenMock.expectedInvocationsOrigin, afterVerifyRefreshTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TokenOperationsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGenerateAccessTokenInspect()

			m.MinimockGenerateRefreshTokenInspect()

			m.MinimockVerifyAccessTokenInspect()

			m.MinimockVerifyRefreshTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TokenOperationsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TokenOperationsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateAccessTokenDone() &&
		m.MinimockGenerateRefreshTokenDone() &&
		m.MinimockVerifyAccessTokenDone() &&
		m.MinimockVerifyRefreshTokenDone()
}
