// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/8thgencore/microservice-auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements mm_repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, user *model.UserCreate) (s1 string, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, user *model.UserCreate)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, id string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcFindByName          func(ctx context.Context, name string) (up1 *model.User, err error)
	funcFindByNameOrigin    string
	inspectFuncFindByName   func(ctx context.Context, name string)
	afterFindByNameCounter  uint64
	beforeFindByNameCounter uint64
	FindByNameMock          mUserRepositoryMockFindByName

	funcGet          func(ctx context.Context, id string) (up1 *model.User, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserRepositoryMockGet

	funcGetAuthInfo          func(ctx context.Context, username string) (ap1 *model.AuthInfo, err error)
	funcGetAuthInfoOrigin    string
	inspectFuncGetAuthInfo   func(ctx context.Context, username string)
	afterGetAuthInfoCounter  uint64
	beforeGetAuthInfoCounter uint64
	GetAuthInfoMock          mUserRepositoryMockGetAuthInfo

	funcUpdate          func(ctx context.Context, user *model.UserUpdate) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, user *model.UserUpdate)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserRepositoryMockUpdate

	funcUpdatePassword          func(ctx context.Context, userID string, hashedPassword string) (err error)
	funcUpdatePasswordOrigin    string
	inspectFuncUpdatePassword   func(ctx context.Context, userID string, hashedPassword string)
	afterUpdatePasswordCounter  uint64
	beforeUpdatePasswordCounter uint64
	UpdatePasswordMock          mUserRepositoryMockUpdatePassword
}

// NewUserRepositoryMock returns a mock for mm_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.FindByNameMock = mUserRepositoryMockFindByName{mock: m}
	m.FindByNameMock.callArgs = []*UserRepositoryMockFindByNameParams{}

	m.GetMock = mUserRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserRepositoryMockGetParams{}

	m.GetAuthInfoMock = mUserRepositoryMockGetAuthInfo{mock: m}
	m.GetAuthInfoMock.callArgs = []*UserRepositoryMockGetAuthInfoParams{}

	m.UpdateMock = mUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserRepositoryMockUpdateParams{}

	m.UpdatePasswordMock = mUserRepositoryMockUpdatePassword{mock: m}
	m.UpdatePasswordMock.callArgs = []*UserRepositoryMockUpdatePasswordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockCreateParams
	paramPtrs          *UserRepositoryMockCreateParamPtrs
	expectationOrigins UserRepositoryMockCreateExpectationOrigins
	results            *UserRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx  context.Context
	user *model.UserCreate
}

// UserRepositoryMockCreateParamPtrs contains pointers to parameters of the UserRepository.Create
type UserRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	user **model.UserCreate
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	s1  string
	err error
}

// UserRepositoryMockCreateOrigins contains origins of expectations of the UserRepository.Create
type UserRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserRepositoryMockCreate) Optional() *mUserRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, user *model.UserCreate) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, user}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserParam2 sets up expected param user for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectUserParam2(user *model.UserCreate) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.user = &user
	mmCreate.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, user *model.UserCreate)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(s1 string, err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{s1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, user *model.UserCreate) (s1 string, err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, user *model.UserCreate) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UserRepositoryMockCreateParams{ctx, user},
		expectationOrigins: UserRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(s1 string, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{s1, err}
	return e.mock
}

// Times sets number of times UserRepository.Create should be invoked
func (mmCreate *mUserRepositoryMockCreate) Times(n uint64) *mUserRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUserRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, user *model.UserCreate) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user)
	}

	mm_params := UserRepositoryMockCreateParams{ctx, user}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, user)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUserRepositoryMockDelete struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockDeleteParams
	paramPtrs          *UserRepositoryMockDeleteParamPtrs
	expectationOrigins UserRepositoryMockDeleteExpectationOrigins
	results            *UserRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx context.Context
	id  string
}

// UserRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *string
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// UserRepositoryMockDeleteOrigins contains origins of expectations of the UserRepository.Delete
type UserRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserRepositoryMockDelete) Optional() *mUserRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, id string) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectIdParam2(id string) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, id string)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, id string) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, id string) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UserRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Delete should be invoked
func (mmDelete *mUserRepositoryMockDelete) Times(n uint64) *mUserRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserRepositoryMockFindByName struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockFindByNameExpectation
	expectations       []*UserRepositoryMockFindByNameExpectation

	callArgs []*UserRepositoryMockFindByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockFindByNameExpectation specifies expectation struct of the UserRepository.FindByName
type UserRepositoryMockFindByNameExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockFindByNameParams
	paramPtrs          *UserRepositoryMockFindByNameParamPtrs
	expectationOrigins UserRepositoryMockFindByNameExpectationOrigins
	results            *UserRepositoryMockFindByNameResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockFindByNameParams contains parameters of the UserRepository.FindByName
type UserRepositoryMockFindByNameParams struct {
	ctx  context.Context
	name string
}

// UserRepositoryMockFindByNameParamPtrs contains pointers to parameters of the UserRepository.FindByName
type UserRepositoryMockFindByNameParamPtrs struct {
	ctx  *context.Context
	name *string
}

// UserRepositoryMockFindByNameResults contains results of the UserRepository.FindByName
type UserRepositoryMockFindByNameResults struct {
	up1 *model.User
	err error
}

// UserRepositoryMockFindByNameOrigins contains origins of expectations of the UserRepository.FindByName
type UserRepositoryMockFindByNameExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindByName *mUserRepositoryMockFindByName) Optional() *mUserRepositoryMockFindByName {
	mmFindByName.optional = true
	return mmFindByName
}

// Expect sets up expected params for UserRepository.FindByName
func (mmFindByName *mUserRepositoryMockFindByName) Expect(ctx context.Context, name string) *mUserRepositoryMockFindByName {
	if mmFindByName.mock.funcFindByName != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Set")
	}

	if mmFindByName.defaultExpectation == nil {
		mmFindByName.defaultExpectation = &UserRepositoryMockFindByNameExpectation{}
	}

	if mmFindByName.defaultExpectation.paramPtrs != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by ExpectParams functions")
	}

	mmFindByName.defaultExpectation.params = &UserRepositoryMockFindByNameParams{ctx, name}
	mmFindByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindByName.expectations {
		if minimock.Equal(e.params, mmFindByName.defaultExpectation.params) {
			mmFindByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindByName.defaultExpectation.params)
		}
	}

	return mmFindByName
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.FindByName
func (mmFindByName *mUserRepositoryMockFindByName) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockFindByName {
	if mmFindByName.mock.funcFindByName != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Set")
	}

	if mmFindByName.defaultExpectation == nil {
		mmFindByName.defaultExpectation = &UserRepositoryMockFindByNameExpectation{}
	}

	if mmFindByName.defaultExpectation.params != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Expect")
	}

	if mmFindByName.defaultExpectation.paramPtrs == nil {
		mmFindByName.defaultExpectation.paramPtrs = &UserRepositoryMockFindByNameParamPtrs{}
	}
	mmFindByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindByName
}

// ExpectNameParam2 sets up expected param name for UserRepository.FindByName
func (mmFindByName *mUserRepositoryMockFindByName) ExpectNameParam2(name string) *mUserRepositoryMockFindByName {
	if mmFindByName.mock.funcFindByName != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Set")
	}

	if mmFindByName.defaultExpectation == nil {
		mmFindByName.defaultExpectation = &UserRepositoryMockFindByNameExpectation{}
	}

	if mmFindByName.defaultExpectation.params != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Expect")
	}

	if mmFindByName.defaultExpectation.paramPtrs == nil {
		mmFindByName.defaultExpectation.paramPtrs = &UserRepositoryMockFindByNameParamPtrs{}
	}
	mmFindByName.defaultExpectation.paramPtrs.name = &name
	mmFindByName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmFindByName
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.FindByName
func (mmFindByName *mUserRepositoryMockFindByName) Inspect(f func(ctx context.Context, name string)) *mUserRepositoryMockFindByName {
	if mmFindByName.mock.inspectFuncFindByName != nil {
		mmFindByName.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.FindByName")
	}

	mmFindByName.mock.inspectFuncFindByName = f

	return mmFindByName
}

// Return sets up results that will be returned by UserRepository.FindByName
func (mmFindByName *mUserRepositoryMockFindByName) Return(up1 *model.User, err error) *UserRepositoryMock {
	if mmFindByName.mock.funcFindByName != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Set")
	}

	if mmFindByName.defaultExpectation == nil {
		mmFindByName.defaultExpectation = &UserRepositoryMockFindByNameExpectation{mock: mmFindByName.mock}
	}
	mmFindByName.defaultExpectation.results = &UserRepositoryMockFindByNameResults{up1, err}
	mmFindByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindByName.mock
}

// Set uses given function f to mock the UserRepository.FindByName method
func (mmFindByName *mUserRepositoryMockFindByName) Set(f func(ctx context.Context, name string) (up1 *model.User, err error)) *UserRepositoryMock {
	if mmFindByName.defaultExpectation != nil {
		mmFindByName.mock.t.Fatalf("Default expectation is already set for the UserRepository.FindByName method")
	}

	if len(mmFindByName.expectations) > 0 {
		mmFindByName.mock.t.Fatalf("Some expectations are already set for the UserRepository.FindByName method")
	}

	mmFindByName.mock.funcFindByName = f
	mmFindByName.mock.funcFindByNameOrigin = minimock.CallerInfo(1)
	return mmFindByName.mock
}

// When sets expectation for the UserRepository.FindByName which will trigger the result defined by the following
// Then helper
func (mmFindByName *mUserRepositoryMockFindByName) When(ctx context.Context, name string) *UserRepositoryMockFindByNameExpectation {
	if mmFindByName.mock.funcFindByName != nil {
		mmFindByName.mock.t.Fatalf("UserRepositoryMock.FindByName mock is already set by Set")
	}

	expectation := &UserRepositoryMockFindByNameExpectation{
		mock:               mmFindByName.mock,
		params:             &UserRepositoryMockFindByNameParams{ctx, name},
		expectationOrigins: UserRepositoryMockFindByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindByName.expectations = append(mmFindByName.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.FindByName return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockFindByNameExpectation) Then(up1 *model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockFindByNameResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.FindByName should be invoked
func (mmFindByName *mUserRepositoryMockFindByName) Times(n uint64) *mUserRepositoryMockFindByName {
	if n == 0 {
		mmFindByName.mock.t.Fatalf("Times of UserRepositoryMock.FindByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindByName.expectedInvocations, n)
	mmFindByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindByName
}

func (mmFindByName *mUserRepositoryMockFindByName) invocationsDone() bool {
	if len(mmFindByName.expectations) == 0 && mmFindByName.defaultExpectation == nil && mmFindByName.mock.funcFindByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindByName.mock.afterFindByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindByName implements mm_repository.UserRepository
func (mmFindByName *UserRepositoryMock) FindByName(ctx context.Context, name string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmFindByName.beforeFindByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmFindByName.afterFindByNameCounter, 1)

	mmFindByName.t.Helper()

	if mmFindByName.inspectFuncFindByName != nil {
		mmFindByName.inspectFuncFindByName(ctx, name)
	}

	mm_params := UserRepositoryMockFindByNameParams{ctx, name}

	// Record call args
	mmFindByName.FindByNameMock.mutex.Lock()
	mmFindByName.FindByNameMock.callArgs = append(mmFindByName.FindByNameMock.callArgs, &mm_params)
	mmFindByName.FindByNameMock.mutex.Unlock()

	for _, e := range mmFindByName.FindByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmFindByName.FindByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindByName.FindByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmFindByName.FindByNameMock.defaultExpectation.params
		mm_want_ptrs := mmFindByName.FindByNameMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockFindByNameParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindByName.t.Errorf("UserRepositoryMock.FindByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindByName.FindByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmFindByName.t.Errorf("UserRepositoryMock.FindByName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindByName.FindByNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindByName.t.Errorf("UserRepositoryMock.FindByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindByName.FindByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindByName.FindByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmFindByName.t.Fatal("No results are set for the UserRepositoryMock.FindByName")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmFindByName.funcFindByName != nil {
		return mmFindByName.funcFindByName(ctx, name)
	}
	mmFindByName.t.Fatalf("Unexpected call to UserRepositoryMock.FindByName. %v %v", ctx, name)
	return
}

// FindByNameAfterCounter returns a count of finished UserRepositoryMock.FindByName invocations
func (mmFindByName *UserRepositoryMock) FindByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByName.afterFindByNameCounter)
}

// FindByNameBeforeCounter returns a count of UserRepositoryMock.FindByName invocations
func (mmFindByName *UserRepositoryMock) FindByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByName.beforeFindByNameCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.FindByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindByName *mUserRepositoryMockFindByName) Calls() []*UserRepositoryMockFindByNameParams {
	mmFindByName.mutex.RLock()

	argCopy := make([]*UserRepositoryMockFindByNameParams, len(mmFindByName.callArgs))
	copy(argCopy, mmFindByName.callArgs)

	mmFindByName.mutex.RUnlock()

	return argCopy
}

// MinimockFindByNameDone returns true if the count of the FindByName invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockFindByNameDone() bool {
	if m.FindByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindByNameMock.invocationsDone()
}

// MinimockFindByNameInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockFindByNameInspect() {
	for _, e := range m.FindByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.FindByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindByNameCounter := mm_atomic.LoadUint64(&m.afterFindByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindByNameMock.defaultExpectation != nil && afterFindByNameCounter < 1 {
		if m.FindByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.FindByName at\n%s", m.FindByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.FindByName at\n%s with params: %#v", m.FindByNameMock.defaultExpectation.expectationOrigins.origin, *m.FindByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindByName != nil && afterFindByNameCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.FindByName at\n%s", m.funcFindByNameOrigin)
	}

	if !m.FindByNameMock.invocationsDone() && afterFindByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.FindByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindByNameMock.expectedInvocations), m.FindByNameMock.expectedInvocationsOrigin, afterFindByNameCounter)
	}
}

type mUserRepositoryMockGet struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetExpectation
	expectations       []*UserRepositoryMockGetExpectation

	callArgs []*UserRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetExpectation specifies expectation struct of the UserRepository.Get
type UserRepositoryMockGetExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetParams
	paramPtrs          *UserRepositoryMockGetParamPtrs
	expectationOrigins UserRepositoryMockGetExpectationOrigins
	results            *UserRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetParams contains parameters of the UserRepository.Get
type UserRepositoryMockGetParams struct {
	ctx context.Context
	id  string
}

// UserRepositoryMockGetParamPtrs contains pointers to parameters of the UserRepository.Get
type UserRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *string
}

// UserRepositoryMockGetResults contains results of the UserRepository.Get
type UserRepositoryMockGetResults struct {
	up1 *model.User
	err error
}

// UserRepositoryMockGetOrigins contains origins of expectations of the UserRepository.Get
type UserRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserRepositoryMockGet) Optional() *mUserRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Expect(ctx context.Context, id string) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectIdParam2(id string) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Inspect(f func(ctx context.Context, id string)) *mUserRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Return(up1 *model.User, err error) *UserRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserRepository.Get method
func (mmGet *mUserRepositoryMockGet) Set(f func(ctx context.Context, id string) (up1 *model.User, err error)) *UserRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserRepositoryMockGet) When(ctx context.Context, id string) *UserRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserRepositoryMockGetParams{ctx, id},
		expectationOrigins: UserRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetExpectation) Then(up1 *model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.Get should be invoked
func (mmGet *mUserRepositoryMockGet) Times(n uint64) *mUserRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UserRepository
func (mmGet *UserRepositoryMock) Get(ctx context.Context, id string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserRepositoryMockGet) Calls() []*UserRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserRepositoryMockGetAuthInfo struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetAuthInfoExpectation
	expectations       []*UserRepositoryMockGetAuthInfoExpectation

	callArgs []*UserRepositoryMockGetAuthInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetAuthInfoExpectation specifies expectation struct of the UserRepository.GetAuthInfo
type UserRepositoryMockGetAuthInfoExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetAuthInfoParams
	paramPtrs          *UserRepositoryMockGetAuthInfoParamPtrs
	expectationOrigins UserRepositoryMockGetAuthInfoExpectationOrigins
	results            *UserRepositoryMockGetAuthInfoResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetAuthInfoParams contains parameters of the UserRepository.GetAuthInfo
type UserRepositoryMockGetAuthInfoParams struct {
	ctx      context.Context
	username string
}

// UserRepositoryMockGetAuthInfoParamPtrs contains pointers to parameters of the UserRepository.GetAuthInfo
type UserRepositoryMockGetAuthInfoParamPtrs struct {
	ctx      *context.Context
	username *string
}

// UserRepositoryMockGetAuthInfoResults contains results of the UserRepository.GetAuthInfo
type UserRepositoryMockGetAuthInfoResults struct {
	ap1 *model.AuthInfo
	err error
}

// UserRepositoryMockGetAuthInfoOrigins contains origins of expectations of the UserRepository.GetAuthInfo
type UserRepositoryMockGetAuthInfoExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Optional() *mUserRepositoryMockGetAuthInfo {
	mmGetAuthInfo.optional = true
	return mmGetAuthInfo
}

// Expect sets up expected params for UserRepository.GetAuthInfo
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Expect(ctx context.Context, username string) *mUserRepositoryMockGetAuthInfo {
	if mmGetAuthInfo.mock.funcGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Set")
	}

	if mmGetAuthInfo.defaultExpectation == nil {
		mmGetAuthInfo.defaultExpectation = &UserRepositoryMockGetAuthInfoExpectation{}
	}

	if mmGetAuthInfo.defaultExpectation.paramPtrs != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by ExpectParams functions")
	}

	mmGetAuthInfo.defaultExpectation.params = &UserRepositoryMockGetAuthInfoParams{ctx, username}
	mmGetAuthInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAuthInfo.expectations {
		if minimock.Equal(e.params, mmGetAuthInfo.defaultExpectation.params) {
			mmGetAuthInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthInfo.defaultExpectation.params)
		}
	}

	return mmGetAuthInfo
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetAuthInfo
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetAuthInfo {
	if mmGetAuthInfo.mock.funcGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Set")
	}

	if mmGetAuthInfo.defaultExpectation == nil {
		mmGetAuthInfo.defaultExpectation = &UserRepositoryMockGetAuthInfoExpectation{}
	}

	if mmGetAuthInfo.defaultExpectation.params != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Expect")
	}

	if mmGetAuthInfo.defaultExpectation.paramPtrs == nil {
		mmGetAuthInfo.defaultExpectation.paramPtrs = &UserRepositoryMockGetAuthInfoParamPtrs{}
	}
	mmGetAuthInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAuthInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAuthInfo
}

// ExpectUsernameParam2 sets up expected param username for UserRepository.GetAuthInfo
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) ExpectUsernameParam2(username string) *mUserRepositoryMockGetAuthInfo {
	if mmGetAuthInfo.mock.funcGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Set")
	}

	if mmGetAuthInfo.defaultExpectation == nil {
		mmGetAuthInfo.defaultExpectation = &UserRepositoryMockGetAuthInfoExpectation{}
	}

	if mmGetAuthInfo.defaultExpectation.params != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Expect")
	}

	if mmGetAuthInfo.defaultExpectation.paramPtrs == nil {
		mmGetAuthInfo.defaultExpectation.paramPtrs = &UserRepositoryMockGetAuthInfoParamPtrs{}
	}
	mmGetAuthInfo.defaultExpectation.paramPtrs.username = &username
	mmGetAuthInfo.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetAuthInfo
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetAuthInfo
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Inspect(f func(ctx context.Context, username string)) *mUserRepositoryMockGetAuthInfo {
	if mmGetAuthInfo.mock.inspectFuncGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetAuthInfo")
	}

	mmGetAuthInfo.mock.inspectFuncGetAuthInfo = f

	return mmGetAuthInfo
}

// Return sets up results that will be returned by UserRepository.GetAuthInfo
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Return(ap1 *model.AuthInfo, err error) *UserRepositoryMock {
	if mmGetAuthInfo.mock.funcGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Set")
	}

	if mmGetAuthInfo.defaultExpectation == nil {
		mmGetAuthInfo.defaultExpectation = &UserRepositoryMockGetAuthInfoExpectation{mock: mmGetAuthInfo.mock}
	}
	mmGetAuthInfo.defaultExpectation.results = &UserRepositoryMockGetAuthInfoResults{ap1, err}
	mmGetAuthInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAuthInfo.mock
}

// Set uses given function f to mock the UserRepository.GetAuthInfo method
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Set(f func(ctx context.Context, username string) (ap1 *model.AuthInfo, err error)) *UserRepositoryMock {
	if mmGetAuthInfo.defaultExpectation != nil {
		mmGetAuthInfo.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetAuthInfo method")
	}

	if len(mmGetAuthInfo.expectations) > 0 {
		mmGetAuthInfo.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetAuthInfo method")
	}

	mmGetAuthInfo.mock.funcGetAuthInfo = f
	mmGetAuthInfo.mock.funcGetAuthInfoOrigin = minimock.CallerInfo(1)
	return mmGetAuthInfo.mock
}

// When sets expectation for the UserRepository.GetAuthInfo which will trigger the result defined by the following
// Then helper
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) When(ctx context.Context, username string) *UserRepositoryMockGetAuthInfoExpectation {
	if mmGetAuthInfo.mock.funcGetAuthInfo != nil {
		mmGetAuthInfo.mock.t.Fatalf("UserRepositoryMock.GetAuthInfo mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetAuthInfoExpectation{
		mock:               mmGetAuthInfo.mock,
		params:             &UserRepositoryMockGetAuthInfoParams{ctx, username},
		expectationOrigins: UserRepositoryMockGetAuthInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAuthInfo.expectations = append(mmGetAuthInfo.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetAuthInfo return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetAuthInfoExpectation) Then(ap1 *model.AuthInfo, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetAuthInfoResults{ap1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetAuthInfo should be invoked
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Times(n uint64) *mUserRepositoryMockGetAuthInfo {
	if n == 0 {
		mmGetAuthInfo.mock.t.Fatalf("Times of UserRepositoryMock.GetAuthInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAuthInfo.expectedInvocations, n)
	mmGetAuthInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAuthInfo
}

func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) invocationsDone() bool {
	if len(mmGetAuthInfo.expectations) == 0 && mmGetAuthInfo.defaultExpectation == nil && mmGetAuthInfo.mock.funcGetAuthInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAuthInfo.mock.afterGetAuthInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAuthInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAuthInfo implements mm_repository.UserRepository
func (mmGetAuthInfo *UserRepositoryMock) GetAuthInfo(ctx context.Context, username string) (ap1 *model.AuthInfo, err error) {
	mm_atomic.AddUint64(&mmGetAuthInfo.beforeGetAuthInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthInfo.afterGetAuthInfoCounter, 1)

	mmGetAuthInfo.t.Helper()

	if mmGetAuthInfo.inspectFuncGetAuthInfo != nil {
		mmGetAuthInfo.inspectFuncGetAuthInfo(ctx, username)
	}

	mm_params := UserRepositoryMockGetAuthInfoParams{ctx, username}

	// Record call args
	mmGetAuthInfo.GetAuthInfoMock.mutex.Lock()
	mmGetAuthInfo.GetAuthInfoMock.callArgs = append(mmGetAuthInfo.GetAuthInfoMock.callArgs, &mm_params)
	mmGetAuthInfo.GetAuthInfoMock.mutex.Unlock()

	for _, e := range mmGetAuthInfo.GetAuthInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetAuthInfo.GetAuthInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetAuthInfoParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAuthInfo.t.Errorf("UserRepositoryMock.GetAuthInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetAuthInfo.t.Errorf("UserRepositoryMock.GetAuthInfo got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthInfo.t.Errorf("UserRepositoryMock.GetAuthInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthInfo.GetAuthInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthInfo.t.Fatal("No results are set for the UserRepositoryMock.GetAuthInfo")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetAuthInfo.funcGetAuthInfo != nil {
		return mmGetAuthInfo.funcGetAuthInfo(ctx, username)
	}
	mmGetAuthInfo.t.Fatalf("Unexpected call to UserRepositoryMock.GetAuthInfo. %v %v", ctx, username)
	return
}

// GetAuthInfoAfterCounter returns a count of finished UserRepositoryMock.GetAuthInfo invocations
func (mmGetAuthInfo *UserRepositoryMock) GetAuthInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthInfo.afterGetAuthInfoCounter)
}

// GetAuthInfoBeforeCounter returns a count of UserRepositoryMock.GetAuthInfo invocations
func (mmGetAuthInfo *UserRepositoryMock) GetAuthInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthInfo.beforeGetAuthInfoCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetAuthInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthInfo *mUserRepositoryMockGetAuthInfo) Calls() []*UserRepositoryMockGetAuthInfoParams {
	mmGetAuthInfo.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetAuthInfoParams, len(mmGetAuthInfo.callArgs))
	copy(argCopy, mmGetAuthInfo.callArgs)

	mmGetAuthInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthInfoDone returns true if the count of the GetAuthInfo invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetAuthInfoDone() bool {
	if m.GetAuthInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAuthInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAuthInfoMock.invocationsDone()
}

// MinimockGetAuthInfoInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetAuthInfoInspect() {
	for _, e := range m.GetAuthInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetAuthInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAuthInfoCounter := mm_atomic.LoadUint64(&m.afterGetAuthInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthInfoMock.defaultExpectation != nil && afterGetAuthInfoCounter < 1 {
		if m.GetAuthInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetAuthInfo at\n%s", m.GetAuthInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetAuthInfo at\n%s with params: %#v", m.GetAuthInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetAuthInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthInfo != nil && afterGetAuthInfoCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetAuthInfo at\n%s", m.funcGetAuthInfoOrigin)
	}

	if !m.GetAuthInfoMock.invocationsDone() && afterGetAuthInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetAuthInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAuthInfoMock.expectedInvocations), m.GetAuthInfoMock.expectedInvocationsOrigin, afterGetAuthInfoCounter)
	}
}

type mUserRepositoryMockUpdate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateExpectation
	expectations       []*UserRepositoryMockUpdateExpectation

	callArgs []*UserRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockUpdateExpectation specifies expectation struct of the UserRepository.Update
type UserRepositoryMockUpdateExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockUpdateParams
	paramPtrs          *UserRepositoryMockUpdateParamPtrs
	expectationOrigins UserRepositoryMockUpdateExpectationOrigins
	results            *UserRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockUpdateParams contains parameters of the UserRepository.Update
type UserRepositoryMockUpdateParams struct {
	ctx  context.Context
	user *model.UserUpdate
}

// UserRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserRepository.Update
type UserRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	user **model.UserUpdate
}

// UserRepositoryMockUpdateResults contains results of the UserRepository.Update
type UserRepositoryMockUpdateResults struct {
	err error
}

// UserRepositoryMockUpdateOrigins contains origins of expectations of the UserRepository.Update
type UserRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserRepositoryMockUpdate) Optional() *mUserRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Expect(ctx context.Context, user *model.UserUpdate) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UserRepositoryMockUpdateParams{ctx, user}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUserParam2 sets up expected param user for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectUserParam2(user *model.UserUpdate) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.user = &user
	mmUpdate.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, user *model.UserUpdate)) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Return(err error) *UserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the UserRepository.Update method
func (mmUpdate *mUserRepositoryMockUpdate) Set(f func(ctx context.Context, user *model.UserUpdate) (err error)) *UserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the UserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserRepositoryMockUpdate) When(ctx context.Context, user *model.UserUpdate) *UserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &UserRepositoryMockUpdateParams{ctx, user},
		expectationOrigins: UserRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Update should be invoked
func (mmUpdate *mUserRepositoryMockUpdate) Times(n uint64) *mUserRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UserRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mUserRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.UserRepository
func (mmUpdate *UserRepositoryMock) Update(ctx context.Context, user *model.UserUpdate) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, user)
	}

	mm_params := UserRepositoryMockUpdateParams{ctx, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserRepositoryMock.Update. %v %v", ctx, user)
	return
}

// UpdateAfterCounter returns a count of finished UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserRepositoryMockUpdate) Calls() []*UserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

type mUserRepositoryMockUpdatePassword struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdatePasswordExpectation
	expectations       []*UserRepositoryMockUpdatePasswordExpectation

	callArgs []*UserRepositoryMockUpdatePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockUpdatePasswordExpectation specifies expectation struct of the UserRepository.UpdatePassword
type UserRepositoryMockUpdatePasswordExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockUpdatePasswordParams
	paramPtrs          *UserRepositoryMockUpdatePasswordParamPtrs
	expectationOrigins UserRepositoryMockUpdatePasswordExpectationOrigins
	results            *UserRepositoryMockUpdatePasswordResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockUpdatePasswordParams contains parameters of the UserRepository.UpdatePassword
type UserRepositoryMockUpdatePasswordParams struct {
	ctx            context.Context
	userID         string
	hashedPassword string
}

// UserRepositoryMockUpdatePasswordParamPtrs contains pointers to parameters of the UserRepository.UpdatePassword
type UserRepositoryMockUpdatePasswordParamPtrs struct {
	ctx            *context.Context
	userID         *string
	hashedPassword *string
}

// UserRepositoryMockUpdatePasswordResults contains results of the UserRepository.UpdatePassword
type UserRepositoryMockUpdatePasswordResults struct {
	err error
}

// UserRepositoryMockUpdatePasswordOrigins contains origins of expectations of the UserRepository.UpdatePassword
type UserRepositoryMockUpdatePasswordExpectationOrigins struct {
	origin               string
	originCtx            string
	originUserID         string
	originHashedPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Optional() *mUserRepositoryMockUpdatePassword {
	mmUpdatePassword.optional = true
	return mmUpdatePassword
}

// Expect sets up expected params for UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Expect(ctx context.Context, userID string, hashedPassword string) *mUserRepositoryMockUpdatePassword {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	if mmUpdatePassword.defaultExpectation == nil {
		mmUpdatePassword.defaultExpectation = &UserRepositoryMockUpdatePasswordExpectation{}
	}

	if mmUpdatePassword.defaultExpectation.paramPtrs != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by ExpectParams functions")
	}

	mmUpdatePassword.defaultExpectation.params = &UserRepositoryMockUpdatePasswordParams{ctx, userID, hashedPassword}
	mmUpdatePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePassword.expectations {
		if minimock.Equal(e.params, mmUpdatePassword.defaultExpectation.params) {
			mmUpdatePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePassword.defaultExpectation.params)
		}
	}

	return mmUpdatePassword
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdatePassword {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	if mmUpdatePassword.defaultExpectation == nil {
		mmUpdatePassword.defaultExpectation = &UserRepositoryMockUpdatePasswordExpectation{}
	}

	if mmUpdatePassword.defaultExpectation.params != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Expect")
	}

	if mmUpdatePassword.defaultExpectation.paramPtrs == nil {
		mmUpdatePassword.defaultExpectation.paramPtrs = &UserRepositoryMockUpdatePasswordParamPtrs{}
	}
	mmUpdatePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePassword
}

// ExpectUserIDParam2 sets up expected param userID for UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) ExpectUserIDParam2(userID string) *mUserRepositoryMockUpdatePassword {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	if mmUpdatePassword.defaultExpectation == nil {
		mmUpdatePassword.defaultExpectation = &UserRepositoryMockUpdatePasswordExpectation{}
	}

	if mmUpdatePassword.defaultExpectation.params != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Expect")
	}

	if mmUpdatePassword.defaultExpectation.paramPtrs == nil {
		mmUpdatePassword.defaultExpectation.paramPtrs = &UserRepositoryMockUpdatePasswordParamPtrs{}
	}
	mmUpdatePassword.defaultExpectation.paramPtrs.userID = &userID
	mmUpdatePassword.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdatePassword
}

// ExpectHashedPasswordParam3 sets up expected param hashedPassword for UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) ExpectHashedPasswordParam3(hashedPassword string) *mUserRepositoryMockUpdatePassword {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	if mmUpdatePassword.defaultExpectation == nil {
		mmUpdatePassword.defaultExpectation = &UserRepositoryMockUpdatePasswordExpectation{}
	}

	if mmUpdatePassword.defaultExpectation.params != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Expect")
	}

	if mmUpdatePassword.defaultExpectation.paramPtrs == nil {
		mmUpdatePassword.defaultExpectation.paramPtrs = &UserRepositoryMockUpdatePasswordParamPtrs{}
	}
	mmUpdatePassword.defaultExpectation.paramPtrs.hashedPassword = &hashedPassword
	mmUpdatePassword.defaultExpectation.expectationOrigins.originHashedPassword = minimock.CallerInfo(1)

	return mmUpdatePassword
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Inspect(f func(ctx context.Context, userID string, hashedPassword string)) *mUserRepositoryMockUpdatePassword {
	if mmUpdatePassword.mock.inspectFuncUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.UpdatePassword")
	}

	mmUpdatePassword.mock.inspectFuncUpdatePassword = f

	return mmUpdatePassword
}

// Return sets up results that will be returned by UserRepository.UpdatePassword
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Return(err error) *UserRepositoryMock {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	if mmUpdatePassword.defaultExpectation == nil {
		mmUpdatePassword.defaultExpectation = &UserRepositoryMockUpdatePasswordExpectation{mock: mmUpdatePassword.mock}
	}
	mmUpdatePassword.defaultExpectation.results = &UserRepositoryMockUpdatePasswordResults{err}
	mmUpdatePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePassword.mock
}

// Set uses given function f to mock the UserRepository.UpdatePassword method
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Set(f func(ctx context.Context, userID string, hashedPassword string) (err error)) *UserRepositoryMock {
	if mmUpdatePassword.defaultExpectation != nil {
		mmUpdatePassword.mock.t.Fatalf("Default expectation is already set for the UserRepository.UpdatePassword method")
	}

	if len(mmUpdatePassword.expectations) > 0 {
		mmUpdatePassword.mock.t.Fatalf("Some expectations are already set for the UserRepository.UpdatePassword method")
	}

	mmUpdatePassword.mock.funcUpdatePassword = f
	mmUpdatePassword.mock.funcUpdatePasswordOrigin = minimock.CallerInfo(1)
	return mmUpdatePassword.mock
}

// When sets expectation for the UserRepository.UpdatePassword which will trigger the result defined by the following
// Then helper
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) When(ctx context.Context, userID string, hashedPassword string) *UserRepositoryMockUpdatePasswordExpectation {
	if mmUpdatePassword.mock.funcUpdatePassword != nil {
		mmUpdatePassword.mock.t.Fatalf("UserRepositoryMock.UpdatePassword mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdatePasswordExpectation{
		mock:               mmUpdatePassword.mock,
		params:             &UserRepositoryMockUpdatePasswordParams{ctx, userID, hashedPassword},
		expectationOrigins: UserRepositoryMockUpdatePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePassword.expectations = append(mmUpdatePassword.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.UpdatePassword return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdatePasswordExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdatePasswordResults{err}
	return e.mock
}

// Times sets number of times UserRepository.UpdatePassword should be invoked
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Times(n uint64) *mUserRepositoryMockUpdatePassword {
	if n == 0 {
		mmUpdatePassword.mock.t.Fatalf("Times of UserRepositoryMock.UpdatePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePassword.expectedInvocations, n)
	mmUpdatePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePassword
}

func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) invocationsDone() bool {
	if len(mmUpdatePassword.expectations) == 0 && mmUpdatePassword.defaultExpectation == nil && mmUpdatePassword.mock.funcUpdatePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePassword.mock.afterUpdatePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePassword implements mm_repository.UserRepository
func (mmUpdatePassword *UserRepositoryMock) UpdatePassword(ctx context.Context, userID string, hashedPassword string) (err error) {
	mm_atomic.AddUint64(&mmUpdatePassword.beforeUpdatePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePassword.afterUpdatePasswordCounter, 1)

	mmUpdatePassword.t.Helper()

	if mmUpdatePassword.inspectFuncUpdatePassword != nil {
		mmUpdatePassword.inspectFuncUpdatePassword(ctx, userID, hashedPassword)
	}

	mm_params := UserRepositoryMockUpdatePasswordParams{ctx, userID, hashedPassword}

	// Record call args
	mmUpdatePassword.UpdatePasswordMock.mutex.Lock()
	mmUpdatePassword.UpdatePasswordMock.callArgs = append(mmUpdatePassword.UpdatePasswordMock.callArgs, &mm_params)
	mmUpdatePassword.UpdatePasswordMock.mutex.Unlock()

	for _, e := range mmUpdatePassword.UpdatePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePassword.UpdatePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePassword.UpdatePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePassword.UpdatePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePassword.UpdatePasswordMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdatePasswordParams{ctx, userID, hashedPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePassword.t.Errorf("UserRepositoryMock.UpdatePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePassword.UpdatePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdatePassword.t.Errorf("UserRepositoryMock.UpdatePassword got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePassword.UpdatePasswordMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.hashedPassword != nil && !minimock.Equal(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword) {
				mmUpdatePassword.t.Errorf("UserRepositoryMock.UpdatePassword got unexpected parameter hashedPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePassword.UpdatePasswordMock.defaultExpectation.expectationOrigins.originHashedPassword, *mm_want_ptrs.hashedPassword, mm_got.hashedPassword, minimock.Diff(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePassword.t.Errorf("UserRepositoryMock.UpdatePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePassword.UpdatePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePassword.UpdatePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePassword.t.Fatal("No results are set for the UserRepositoryMock.UpdatePassword")
		}
		return (*mm_results).err
	}
	if mmUpdatePassword.funcUpdatePassword != nil {
		return mmUpdatePassword.funcUpdatePassword(ctx, userID, hashedPassword)
	}
	mmUpdatePassword.t.Fatalf("Unexpected call to UserRepositoryMock.UpdatePassword. %v %v %v", ctx, userID, hashedPassword)
	return
}

// UpdatePasswordAfterCounter returns a count of finished UserRepositoryMock.UpdatePassword invocations
func (mmUpdatePassword *UserRepositoryMock) UpdatePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePassword.afterUpdatePasswordCounter)
}

// UpdatePasswordBeforeCounter returns a count of UserRepositoryMock.UpdatePassword invocations
func (mmUpdatePassword *UserRepositoryMock) UpdatePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePassword.beforeUpdatePasswordCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.UpdatePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePassword *mUserRepositoryMockUpdatePassword) Calls() []*UserRepositoryMockUpdatePasswordParams {
	mmUpdatePassword.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdatePasswordParams, len(mmUpdatePassword.callArgs))
	copy(argCopy, mmUpdatePassword.callArgs)

	mmUpdatePassword.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePasswordDone returns true if the count of the UpdatePassword invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdatePasswordDone() bool {
	if m.UpdatePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePasswordMock.invocationsDone()
}

// MinimockUpdatePasswordInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdatePasswordInspect() {
	for _, e := range m.UpdatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdatePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePasswordCounter := mm_atomic.LoadUint64(&m.afterUpdatePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePasswordMock.defaultExpectation != nil && afterUpdatePasswordCounter < 1 {
		if m.UpdatePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdatePassword at\n%s", m.UpdatePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdatePassword at\n%s with params: %#v", m.UpdatePasswordMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePassword != nil && afterUpdatePasswordCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.UpdatePassword at\n%s", m.funcUpdatePasswordOrigin)
	}

	if !m.UpdatePasswordMock.invocationsDone() && afterUpdatePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.UpdatePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePasswordMock.expectedInvocations), m.UpdatePasswordMock.expectedInvocationsOrigin, afterUpdatePasswordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockFindByNameInspect()

			m.MinimockGetInspect()

			m.MinimockGetAuthInfoInspect()

			m.MinimockUpdateInspect()

			m.MinimockUpdatePasswordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockFindByNameDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAuthInfoDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdatePasswordDone()
}
