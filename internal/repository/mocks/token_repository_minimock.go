// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TokenRepositoryMock implements mm_repository.TokenRepository
type TokenRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddRevokedToken          func(ctx context.Context, refreshToken string) (err error)
	funcAddRevokedTokenOrigin    string
	inspectFuncAddRevokedToken   func(ctx context.Context, refreshToken string)
	afterAddRevokedTokenCounter  uint64
	beforeAddRevokedTokenCounter uint64
	AddRevokedTokenMock          mTokenRepositoryMockAddRevokedToken

	funcGetTokenVersion          func(ctx context.Context, userID string) (i1 int, err error)
	funcGetTokenVersionOrigin    string
	inspectFuncGetTokenVersion   func(ctx context.Context, userID string)
	afterGetTokenVersionCounter  uint64
	beforeGetTokenVersionCounter uint64
	GetTokenVersionMock          mTokenRepositoryMockGetTokenVersion

	funcIsTokenRevoked          func(ctx context.Context, refreshToken string) (b1 bool, err error)
	funcIsTokenRevokedOrigin    string
	inspectFuncIsTokenRevoked   func(ctx context.Context, refreshToken string)
	afterIsTokenRevokedCounter  uint64
	beforeIsTokenRevokedCounter uint64
	IsTokenRevokedMock          mTokenRepositoryMockIsTokenRevoked

	funcSetTokenVersion          func(ctx context.Context, userID string, version int) (err error)
	funcSetTokenVersionOrigin    string
	inspectFuncSetTokenVersion   func(ctx context.Context, userID string, version int)
	afterSetTokenVersionCounter  uint64
	beforeSetTokenVersionCounter uint64
	SetTokenVersionMock          mTokenRepositoryMockSetTokenVersion
}

// NewTokenRepositoryMock returns a mock for mm_repository.TokenRepository
func NewTokenRepositoryMock(t minimock.Tester) *TokenRepositoryMock {
	m := &TokenRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRevokedTokenMock = mTokenRepositoryMockAddRevokedToken{mock: m}
	m.AddRevokedTokenMock.callArgs = []*TokenRepositoryMockAddRevokedTokenParams{}

	m.GetTokenVersionMock = mTokenRepositoryMockGetTokenVersion{mock: m}
	m.GetTokenVersionMock.callArgs = []*TokenRepositoryMockGetTokenVersionParams{}

	m.IsTokenRevokedMock = mTokenRepositoryMockIsTokenRevoked{mock: m}
	m.IsTokenRevokedMock.callArgs = []*TokenRepositoryMockIsTokenRevokedParams{}

	m.SetTokenVersionMock = mTokenRepositoryMockSetTokenVersion{mock: m}
	m.SetTokenVersionMock.callArgs = []*TokenRepositoryMockSetTokenVersionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTokenRepositoryMockAddRevokedToken struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockAddRevokedTokenExpectation
	expectations       []*TokenRepositoryMockAddRevokedTokenExpectation

	callArgs []*TokenRepositoryMockAddRevokedTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockAddRevokedTokenExpectation specifies expectation struct of the TokenRepository.AddRevokedToken
type TokenRepositoryMockAddRevokedTokenExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockAddRevokedTokenParams
	paramPtrs          *TokenRepositoryMockAddRevokedTokenParamPtrs
	expectationOrigins TokenRepositoryMockAddRevokedTokenExpectationOrigins
	results            *TokenRepositoryMockAddRevokedTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockAddRevokedTokenParams contains parameters of the TokenRepository.AddRevokedToken
type TokenRepositoryMockAddRevokedTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// TokenRepositoryMockAddRevokedTokenParamPtrs contains pointers to parameters of the TokenRepository.AddRevokedToken
type TokenRepositoryMockAddRevokedTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// TokenRepositoryMockAddRevokedTokenResults contains results of the TokenRepository.AddRevokedToken
type TokenRepositoryMockAddRevokedTokenResults struct {
	err error
}

// TokenRepositoryMockAddRevokedTokenOrigins contains origins of expectations of the TokenRepository.AddRevokedToken
type TokenRepositoryMockAddRevokedTokenExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Optional() *mTokenRepositoryMockAddRevokedToken {
	mmAddRevokedToken.optional = true
	return mmAddRevokedToken
}

// Expect sets up expected params for TokenRepository.AddRevokedToken
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Expect(ctx context.Context, refreshToken string) *mTokenRepositoryMockAddRevokedToken {
	if mmAddRevokedToken.mock.funcAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Set")
	}

	if mmAddRevokedToken.defaultExpectation == nil {
		mmAddRevokedToken.defaultExpectation = &TokenRepositoryMockAddRevokedTokenExpectation{}
	}

	if mmAddRevokedToken.defaultExpectation.paramPtrs != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by ExpectParams functions")
	}

	mmAddRevokedToken.defaultExpectation.params = &TokenRepositoryMockAddRevokedTokenParams{ctx, refreshToken}
	mmAddRevokedToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddRevokedToken.expectations {
		if minimock.Equal(e.params, mmAddRevokedToken.defaultExpectation.params) {
			mmAddRevokedToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRevokedToken.defaultExpectation.params)
		}
	}

	return mmAddRevokedToken
}

// ExpectCtxParam1 sets up expected param ctx for TokenRepository.AddRevokedToken
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) ExpectCtxParam1(ctx context.Context) *mTokenRepositoryMockAddRevokedToken {
	if mmAddRevokedToken.mock.funcAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Set")
	}

	if mmAddRevokedToken.defaultExpectation == nil {
		mmAddRevokedToken.defaultExpectation = &TokenRepositoryMockAddRevokedTokenExpectation{}
	}

	if mmAddRevokedToken.defaultExpectation.params != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Expect")
	}

	if mmAddRevokedToken.defaultExpectation.paramPtrs == nil {
		mmAddRevokedToken.defaultExpectation.paramPtrs = &TokenRepositoryMockAddRevokedTokenParamPtrs{}
	}
	mmAddRevokedToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddRevokedToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddRevokedToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for TokenRepository.AddRevokedToken
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) ExpectRefreshTokenParam2(refreshToken string) *mTokenRepositoryMockAddRevokedToken {
	if mmAddRevokedToken.mock.funcAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Set")
	}

	if mmAddRevokedToken.defaultExpectation == nil {
		mmAddRevokedToken.defaultExpectation = &TokenRepositoryMockAddRevokedTokenExpectation{}
	}

	if mmAddRevokedToken.defaultExpectation.params != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Expect")
	}

	if mmAddRevokedToken.defaultExpectation.paramPtrs == nil {
		mmAddRevokedToken.defaultExpectation.paramPtrs = &TokenRepositoryMockAddRevokedTokenParamPtrs{}
	}
	mmAddRevokedToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmAddRevokedToken.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmAddRevokedToken
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.AddRevokedToken
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Inspect(f func(ctx context.Context, refreshToken string)) *mTokenRepositoryMockAddRevokedToken {
	if mmAddRevokedToken.mock.inspectFuncAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.AddRevokedToken")
	}

	mmAddRevokedToken.mock.inspectFuncAddRevokedToken = f

	return mmAddRevokedToken
}

// Return sets up results that will be returned by TokenRepository.AddRevokedToken
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Return(err error) *TokenRepositoryMock {
	if mmAddRevokedToken.mock.funcAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Set")
	}

	if mmAddRevokedToken.defaultExpectation == nil {
		mmAddRevokedToken.defaultExpectation = &TokenRepositoryMockAddRevokedTokenExpectation{mock: mmAddRevokedToken.mock}
	}
	mmAddRevokedToken.defaultExpectation.results = &TokenRepositoryMockAddRevokedTokenResults{err}
	mmAddRevokedToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddRevokedToken.mock
}

// Set uses given function f to mock the TokenRepository.AddRevokedToken method
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Set(f func(ctx context.Context, refreshToken string) (err error)) *TokenRepositoryMock {
	if mmAddRevokedToken.defaultExpectation != nil {
		mmAddRevokedToken.mock.t.Fatalf("Default expectation is already set for the TokenRepository.AddRevokedToken method")
	}

	if len(mmAddRevokedToken.expectations) > 0 {
		mmAddRevokedToken.mock.t.Fatalf("Some expectations are already set for the TokenRepository.AddRevokedToken method")
	}

	mmAddRevokedToken.mock.funcAddRevokedToken = f
	mmAddRevokedToken.mock.funcAddRevokedTokenOrigin = minimock.CallerInfo(1)
	return mmAddRevokedToken.mock
}

// When sets expectation for the TokenRepository.AddRevokedToken which will trigger the result defined by the following
// Then helper
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) When(ctx context.Context, refreshToken string) *TokenRepositoryMockAddRevokedTokenExpectation {
	if mmAddRevokedToken.mock.funcAddRevokedToken != nil {
		mmAddRevokedToken.mock.t.Fatalf("TokenRepositoryMock.AddRevokedToken mock is already set by Set")
	}

	expectation := &TokenRepositoryMockAddRevokedTokenExpectation{
		mock:               mmAddRevokedToken.mock,
		params:             &TokenRepositoryMockAddRevokedTokenParams{ctx, refreshToken},
		expectationOrigins: TokenRepositoryMockAddRevokedTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddRevokedToken.expectations = append(mmAddRevokedToken.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.AddRevokedToken return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockAddRevokedTokenExpectation) Then(err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockAddRevokedTokenResults{err}
	return e.mock
}

// Times sets number of times TokenRepository.AddRevokedToken should be invoked
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Times(n uint64) *mTokenRepositoryMockAddRevokedToken {
	if n == 0 {
		mmAddRevokedToken.mock.t.Fatalf("Times of TokenRepositoryMock.AddRevokedToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddRevokedToken.expectedInvocations, n)
	mmAddRevokedToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddRevokedToken
}

func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) invocationsDone() bool {
	if len(mmAddRevokedToken.expectations) == 0 && mmAddRevokedToken.defaultExpectation == nil && mmAddRevokedToken.mock.funcAddRevokedToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddRevokedToken.mock.afterAddRevokedTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddRevokedToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddRevokedToken implements mm_repository.TokenRepository
func (mmAddRevokedToken *TokenRepositoryMock) AddRevokedToken(ctx context.Context, refreshToken string) (err error) {
	mm_atomic.AddUint64(&mmAddRevokedToken.beforeAddRevokedTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRevokedToken.afterAddRevokedTokenCounter, 1)

	mmAddRevokedToken.t.Helper()

	if mmAddRevokedToken.inspectFuncAddRevokedToken != nil {
		mmAddRevokedToken.inspectFuncAddRevokedToken(ctx, refreshToken)
	}

	mm_params := TokenRepositoryMockAddRevokedTokenParams{ctx, refreshToken}

	// Record call args
	mmAddRevokedToken.AddRevokedTokenMock.mutex.Lock()
	mmAddRevokedToken.AddRevokedTokenMock.callArgs = append(mmAddRevokedToken.AddRevokedTokenMock.callArgs, &mm_params)
	mmAddRevokedToken.AddRevokedTokenMock.mutex.Unlock()

	for _, e := range mmAddRevokedToken.AddRevokedTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.params
		mm_want_ptrs := mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockAddRevokedTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddRevokedToken.t.Errorf("TokenRepositoryMock.AddRevokedToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmAddRevokedToken.t.Errorf("TokenRepositoryMock.AddRevokedToken got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRevokedToken.t.Errorf("TokenRepositoryMock.AddRevokedToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRevokedToken.AddRevokedTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRevokedToken.t.Fatal("No results are set for the TokenRepositoryMock.AddRevokedToken")
		}
		return (*mm_results).err
	}
	if mmAddRevokedToken.funcAddRevokedToken != nil {
		return mmAddRevokedToken.funcAddRevokedToken(ctx, refreshToken)
	}
	mmAddRevokedToken.t.Fatalf("Unexpected call to TokenRepositoryMock.AddRevokedToken. %v %v", ctx, refreshToken)
	return
}

// AddRevokedTokenAfterCounter returns a count of finished TokenRepositoryMock.AddRevokedToken invocations
func (mmAddRevokedToken *TokenRepositoryMock) AddRevokedTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRevokedToken.afterAddRevokedTokenCounter)
}

// AddRevokedTokenBeforeCounter returns a count of TokenRepositoryMock.AddRevokedToken invocations
func (mmAddRevokedToken *TokenRepositoryMock) AddRevokedTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRevokedToken.beforeAddRevokedTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.AddRevokedToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRevokedToken *mTokenRepositoryMockAddRevokedToken) Calls() []*TokenRepositoryMockAddRevokedTokenParams {
	mmAddRevokedToken.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockAddRevokedTokenParams, len(mmAddRevokedToken.callArgs))
	copy(argCopy, mmAddRevokedToken.callArgs)

	mmAddRevokedToken.mutex.RUnlock()

	return argCopy
}

// MinimockAddRevokedTokenDone returns true if the count of the AddRevokedToken invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockAddRevokedTokenDone() bool {
	if m.AddRevokedTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddRevokedTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddRevokedTokenMock.invocationsDone()
}

// MinimockAddRevokedTokenInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockAddRevokedTokenInspect() {
	for _, e := range m.AddRevokedTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.AddRevokedToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddRevokedTokenCounter := mm_atomic.LoadUint64(&m.afterAddRevokedTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddRevokedTokenMock.defaultExpectation != nil && afterAddRevokedTokenCounter < 1 {
		if m.AddRevokedTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.AddRevokedToken at\n%s", m.AddRevokedTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.AddRevokedToken at\n%s with params: %#v", m.AddRevokedTokenMock.defaultExpectation.expectationOrigins.origin, *m.AddRevokedTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRevokedToken != nil && afterAddRevokedTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.AddRevokedToken at\n%s", m.funcAddRevokedTokenOrigin)
	}

	if !m.AddRevokedTokenMock.invocationsDone() && afterAddRevokedTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.AddRevokedToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddRevokedTokenMock.expectedInvocations), m.AddRevokedTokenMock.expectedInvocationsOrigin, afterAddRevokedTokenCounter)
	}
}

type mTokenRepositoryMockGetTokenVersion struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockGetTokenVersionExpectation
	expectations       []*TokenRepositoryMockGetTokenVersionExpectation

	callArgs []*TokenRepositoryMockGetTokenVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockGetTokenVersionExpectation specifies expectation struct of the TokenRepository.GetTokenVersion
type TokenRepositoryMockGetTokenVersionExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockGetTokenVersionParams
	paramPtrs          *TokenRepositoryMockGetTokenVersionParamPtrs
	expectationOrigins TokenRepositoryMockGetTokenVersionExpectationOrigins
	results            *TokenRepositoryMockGetTokenVersionResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockGetTokenVersionParams contains parameters of the TokenRepository.GetTokenVersion
type TokenRepositoryMockGetTokenVersionParams struct {
	ctx    context.Context
	userID string
}

// TokenRepositoryMockGetTokenVersionParamPtrs contains pointers to parameters of the TokenRepository.GetTokenVersion
type TokenRepositoryMockGetTokenVersionParamPtrs struct {
	ctx    *context.Context
	userID *string
}

// TokenRepositoryMockGetTokenVersionResults contains results of the TokenRepository.GetTokenVersion
type TokenRepositoryMockGetTokenVersionResults struct {
	i1  int
	err error
}

// TokenRepositoryMockGetTokenVersionOrigins contains origins of expectations of the TokenRepository.GetTokenVersion
type TokenRepositoryMockGetTokenVersionExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Optional() *mTokenRepositoryMockGetTokenVersion {
	mmGetTokenVersion.optional = true
	return mmGetTokenVersion
}

// Expect sets up expected params for TokenRepository.GetTokenVersion
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Expect(ctx context.Context, userID string) *mTokenRepositoryMockGetTokenVersion {
	if mmGetTokenVersion.mock.funcGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Set")
	}

	if mmGetTokenVersion.defaultExpectation == nil {
		mmGetTokenVersion.defaultExpectation = &TokenRepositoryMockGetTokenVersionExpectation{}
	}

	if mmGetTokenVersion.defaultExpectation.paramPtrs != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by ExpectParams functions")
	}

	mmGetTokenVersion.defaultExpectation.params = &TokenRepositoryMockGetTokenVersionParams{ctx, userID}
	mmGetTokenVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTokenVersion.expectations {
		if minimock.Equal(e.params, mmGetTokenVersion.defaultExpectation.params) {
			mmGetTokenVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTokenVersion.defaultExpectation.params)
		}
	}

	return mmGetTokenVersion
}

// ExpectCtxParam1 sets up expected param ctx for TokenRepository.GetTokenVersion
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) ExpectCtxParam1(ctx context.Context) *mTokenRepositoryMockGetTokenVersion {
	if mmGetTokenVersion.mock.funcGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Set")
	}

	if mmGetTokenVersion.defaultExpectation == nil {
		mmGetTokenVersion.defaultExpectation = &TokenRepositoryMockGetTokenVersionExpectation{}
	}

	if mmGetTokenVersion.defaultExpectation.params != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Expect")
	}

	if mmGetTokenVersion.defaultExpectation.paramPtrs == nil {
		mmGetTokenVersion.defaultExpectation.paramPtrs = &TokenRepositoryMockGetTokenVersionParamPtrs{}
	}
	mmGetTokenVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTokenVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTokenVersion
}

// ExpectUserIDParam2 sets up expected param userID for TokenRepository.GetTokenVersion
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) ExpectUserIDParam2(userID string) *mTokenRepositoryMockGetTokenVersion {
	if mmGetTokenVersion.mock.funcGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Set")
	}

	if mmGetTokenVersion.defaultExpectation == nil {
		mmGetTokenVersion.defaultExpectation = &TokenRepositoryMockGetTokenVersionExpectation{}
	}

	if mmGetTokenVersion.defaultExpectation.params != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Expect")
	}

	if mmGetTokenVersion.defaultExpectation.paramPtrs == nil {
		mmGetTokenVersion.defaultExpectation.paramPtrs = &TokenRepositoryMockGetTokenVersionParamPtrs{}
	}
	mmGetTokenVersion.defaultExpectation.paramPtrs.userID = &userID
	mmGetTokenVersion.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetTokenVersion
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.GetTokenVersion
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Inspect(f func(ctx context.Context, userID string)) *mTokenRepositoryMockGetTokenVersion {
	if mmGetTokenVersion.mock.inspectFuncGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.GetTokenVersion")
	}

	mmGetTokenVersion.mock.inspectFuncGetTokenVersion = f

	return mmGetTokenVersion
}

// Return sets up results that will be returned by TokenRepository.GetTokenVersion
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Return(i1 int, err error) *TokenRepositoryMock {
	if mmGetTokenVersion.mock.funcGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Set")
	}

	if mmGetTokenVersion.defaultExpectation == nil {
		mmGetTokenVersion.defaultExpectation = &TokenRepositoryMockGetTokenVersionExpectation{mock: mmGetTokenVersion.mock}
	}
	mmGetTokenVersion.defaultExpectation.results = &TokenRepositoryMockGetTokenVersionResults{i1, err}
	mmGetTokenVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTokenVersion.mock
}

// Set uses given function f to mock the TokenRepository.GetTokenVersion method
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Set(f func(ctx context.Context, userID string) (i1 int, err error)) *TokenRepositoryMock {
	if mmGetTokenVersion.defaultExpectation != nil {
		mmGetTokenVersion.mock.t.Fatalf("Default expectation is already set for the TokenRepository.GetTokenVersion method")
	}

	if len(mmGetTokenVersion.expectations) > 0 {
		mmGetTokenVersion.mock.t.Fatalf("Some expectations are already set for the TokenRepository.GetTokenVersion method")
	}

	mmGetTokenVersion.mock.funcGetTokenVersion = f
	mmGetTokenVersion.mock.funcGetTokenVersionOrigin = minimock.CallerInfo(1)
	return mmGetTokenVersion.mock
}

// When sets expectation for the TokenRepository.GetTokenVersion which will trigger the result defined by the following
// Then helper
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) When(ctx context.Context, userID string) *TokenRepositoryMockGetTokenVersionExpectation {
	if mmGetTokenVersion.mock.funcGetTokenVersion != nil {
		mmGetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.GetTokenVersion mock is already set by Set")
	}

	expectation := &TokenRepositoryMockGetTokenVersionExpectation{
		mock:               mmGetTokenVersion.mock,
		params:             &TokenRepositoryMockGetTokenVersionParams{ctx, userID},
		expectationOrigins: TokenRepositoryMockGetTokenVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTokenVersion.expectations = append(mmGetTokenVersion.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.GetTokenVersion return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockGetTokenVersionExpectation) Then(i1 int, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockGetTokenVersionResults{i1, err}
	return e.mock
}

// Times sets number of times TokenRepository.GetTokenVersion should be invoked
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Times(n uint64) *mTokenRepositoryMockGetTokenVersion {
	if n == 0 {
		mmGetTokenVersion.mock.t.Fatalf("Times of TokenRepositoryMock.GetTokenVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTokenVersion.expectedInvocations, n)
	mmGetTokenVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTokenVersion
}

func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) invocationsDone() bool {
	if len(mmGetTokenVersion.expectations) == 0 && mmGetTokenVersion.defaultExpectation == nil && mmGetTokenVersion.mock.funcGetTokenVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTokenVersion.mock.afterGetTokenVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTokenVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTokenVersion implements mm_repository.TokenRepository
func (mmGetTokenVersion *TokenRepositoryMock) GetTokenVersion(ctx context.Context, userID string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTokenVersion.beforeGetTokenVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTokenVersion.afterGetTokenVersionCounter, 1)

	mmGetTokenVersion.t.Helper()

	if mmGetTokenVersion.inspectFuncGetTokenVersion != nil {
		mmGetTokenVersion.inspectFuncGetTokenVersion(ctx, userID)
	}

	mm_params := TokenRepositoryMockGetTokenVersionParams{ctx, userID}

	// Record call args
	mmGetTokenVersion.GetTokenVersionMock.mutex.Lock()
	mmGetTokenVersion.GetTokenVersionMock.callArgs = append(mmGetTokenVersion.GetTokenVersionMock.callArgs, &mm_params)
	mmGetTokenVersion.GetTokenVersionMock.mutex.Unlock()

	for _, e := range mmGetTokenVersion.GetTokenVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTokenVersion.GetTokenVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockGetTokenVersionParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTokenVersion.t.Errorf("TokenRepositoryMock.GetTokenVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetTokenVersion.t.Errorf("TokenRepositoryMock.GetTokenVersion got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTokenVersion.t.Errorf("TokenRepositoryMock.GetTokenVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTokenVersion.GetTokenVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTokenVersion.t.Fatal("No results are set for the TokenRepositoryMock.GetTokenVersion")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTokenVersion.funcGetTokenVersion != nil {
		return mmGetTokenVersion.funcGetTokenVersion(ctx, userID)
	}
	mmGetTokenVersion.t.Fatalf("Unexpected call to TokenRepositoryMock.GetTokenVersion. %v %v", ctx, userID)
	return
}

// GetTokenVersionAfterCounter returns a count of finished TokenRepositoryMock.GetTokenVersion invocations
func (mmGetTokenVersion *TokenRepositoryMock) GetTokenVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTokenVersion.afterGetTokenVersionCounter)
}

// GetTokenVersionBeforeCounter returns a count of TokenRepositoryMock.GetTokenVersion invocations
func (mmGetTokenVersion *TokenRepositoryMock) GetTokenVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTokenVersion.beforeGetTokenVersionCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.GetTokenVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTokenVersion *mTokenRepositoryMockGetTokenVersion) Calls() []*TokenRepositoryMockGetTokenVersionParams {
	mmGetTokenVersion.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockGetTokenVersionParams, len(mmGetTokenVersion.callArgs))
	copy(argCopy, mmGetTokenVersion.callArgs)

	mmGetTokenVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetTokenVersionDone returns true if the count of the GetTokenVersion invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockGetTokenVersionDone() bool {
	if m.GetTokenVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTokenVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTokenVersionMock.invocationsDone()
}

// MinimockGetTokenVersionInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockGetTokenVersionInspect() {
	for _, e := range m.GetTokenVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.GetTokenVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTokenVersionCounter := mm_atomic.LoadUint64(&m.afterGetTokenVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTokenVersionMock.defaultExpectation != nil && afterGetTokenVersionCounter < 1 {
		if m.GetTokenVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.GetTokenVersion at\n%s", m.GetTokenVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.GetTokenVersion at\n%s with params: %#v", m.GetTokenVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetTokenVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTokenVersion != nil && afterGetTokenVersionCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.GetTokenVersion at\n%s", m.funcGetTokenVersionOrigin)
	}

	if !m.GetTokenVersionMock.invocationsDone() && afterGetTokenVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.GetTokenVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTokenVersionMock.expectedInvocations), m.GetTokenVersionMock.expectedInvocationsOrigin, afterGetTokenVersionCounter)
	}
}

type mTokenRepositoryMockIsTokenRevoked struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockIsTokenRevokedExpectation
	expectations       []*TokenRepositoryMockIsTokenRevokedExpectation

	callArgs []*TokenRepositoryMockIsTokenRevokedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockIsTokenRevokedExpectation specifies expectation struct of the TokenRepository.IsTokenRevoked
type TokenRepositoryMockIsTokenRevokedExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockIsTokenRevokedParams
	paramPtrs          *TokenRepositoryMockIsTokenRevokedParamPtrs
	expectationOrigins TokenRepositoryMockIsTokenRevokedExpectationOrigins
	results            *TokenRepositoryMockIsTokenRevokedResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockIsTokenRevokedParams contains parameters of the TokenRepository.IsTokenRevoked
type TokenRepositoryMockIsTokenRevokedParams struct {
	ctx          context.Context
	refreshToken string
}

// TokenRepositoryMockIsTokenRevokedParamPtrs contains pointers to parameters of the TokenRepository.IsTokenRevoked
type TokenRepositoryMockIsTokenRevokedParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// TokenRepositoryMockIsTokenRevokedResults contains results of the TokenRepository.IsTokenRevoked
type TokenRepositoryMockIsTokenRevokedResults struct {
	b1  bool
	err error
}

// TokenRepositoryMockIsTokenRevokedOrigins contains origins of expectations of the TokenRepository.IsTokenRevoked
type TokenRepositoryMockIsTokenRevokedExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Optional() *mTokenRepositoryMockIsTokenRevoked {
	mmIsTokenRevoked.optional = true
	return mmIsTokenRevoked
}

// Expect sets up expected params for TokenRepository.IsTokenRevoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Expect(ctx context.Context, refreshToken string) *mTokenRepositoryMockIsTokenRevoked {
	if mmIsTokenRevoked.mock.funcIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Set")
	}

	if mmIsTokenRevoked.defaultExpectation == nil {
		mmIsTokenRevoked.defaultExpectation = &TokenRepositoryMockIsTokenRevokedExpectation{}
	}

	if mmIsTokenRevoked.defaultExpectation.paramPtrs != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by ExpectParams functions")
	}

	mmIsTokenRevoked.defaultExpectation.params = &TokenRepositoryMockIsTokenRevokedParams{ctx, refreshToken}
	mmIsTokenRevoked.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsTokenRevoked.expectations {
		if minimock.Equal(e.params, mmIsTokenRevoked.defaultExpectation.params) {
			mmIsTokenRevoked.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsTokenRevoked.defaultExpectation.params)
		}
	}

	return mmIsTokenRevoked
}

// ExpectCtxParam1 sets up expected param ctx for TokenRepository.IsTokenRevoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) ExpectCtxParam1(ctx context.Context) *mTokenRepositoryMockIsTokenRevoked {
	if mmIsTokenRevoked.mock.funcIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Set")
	}

	if mmIsTokenRevoked.defaultExpectation == nil {
		mmIsTokenRevoked.defaultExpectation = &TokenRepositoryMockIsTokenRevokedExpectation{}
	}

	if mmIsTokenRevoked.defaultExpectation.params != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Expect")
	}

	if mmIsTokenRevoked.defaultExpectation.paramPtrs == nil {
		mmIsTokenRevoked.defaultExpectation.paramPtrs = &TokenRepositoryMockIsTokenRevokedParamPtrs{}
	}
	mmIsTokenRevoked.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsTokenRevoked.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsTokenRevoked
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for TokenRepository.IsTokenRevoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) ExpectRefreshTokenParam2(refreshToken string) *mTokenRepositoryMockIsTokenRevoked {
	if mmIsTokenRevoked.mock.funcIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Set")
	}

	if mmIsTokenRevoked.defaultExpectation == nil {
		mmIsTokenRevoked.defaultExpectation = &TokenRepositoryMockIsTokenRevokedExpectation{}
	}

	if mmIsTokenRevoked.defaultExpectation.params != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Expect")
	}

	if mmIsTokenRevoked.defaultExpectation.paramPtrs == nil {
		mmIsTokenRevoked.defaultExpectation.paramPtrs = &TokenRepositoryMockIsTokenRevokedParamPtrs{}
	}
	mmIsTokenRevoked.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmIsTokenRevoked.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmIsTokenRevoked
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.IsTokenRevoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Inspect(f func(ctx context.Context, refreshToken string)) *mTokenRepositoryMockIsTokenRevoked {
	if mmIsTokenRevoked.mock.inspectFuncIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.IsTokenRevoked")
	}

	mmIsTokenRevoked.mock.inspectFuncIsTokenRevoked = f

	return mmIsTokenRevoked
}

// Return sets up results that will be returned by TokenRepository.IsTokenRevoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Return(b1 bool, err error) *TokenRepositoryMock {
	if mmIsTokenRevoked.mock.funcIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Set")
	}

	if mmIsTokenRevoked.defaultExpectation == nil {
		mmIsTokenRevoked.defaultExpectation = &TokenRepositoryMockIsTokenRevokedExpectation{mock: mmIsTokenRevoked.mock}
	}
	mmIsTokenRevoked.defaultExpectation.results = &TokenRepositoryMockIsTokenRevokedResults{b1, err}
	mmIsTokenRevoked.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsTokenRevoked.mock
}

// Set uses given function f to mock the TokenRepository.IsTokenRevoked method
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Set(f func(ctx context.Context, refreshToken string) (b1 bool, err error)) *TokenRepositoryMock {
	if mmIsTokenRevoked.defaultExpectation != nil {
		mmIsTokenRevoked.mock.t.Fatalf("Default expectation is already set for the TokenRepository.IsTokenRevoked method")
	}

	if len(mmIsTokenRevoked.expectations) > 0 {
		mmIsTokenRevoked.mock.t.Fatalf("Some expectations are already set for the TokenRepository.IsTokenRevoked method")
	}

	mmIsTokenRevoked.mock.funcIsTokenRevoked = f
	mmIsTokenRevoked.mock.funcIsTokenRevokedOrigin = minimock.CallerInfo(1)
	return mmIsTokenRevoked.mock
}

// When sets expectation for the TokenRepository.IsTokenRevoked which will trigger the result defined by the following
// Then helper
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) When(ctx context.Context, refreshToken string) *TokenRepositoryMockIsTokenRevokedExpectation {
	if mmIsTokenRevoked.mock.funcIsTokenRevoked != nil {
		mmIsTokenRevoked.mock.t.Fatalf("TokenRepositoryMock.IsTokenRevoked mock is already set by Set")
	}

	expectation := &TokenRepositoryMockIsTokenRevokedExpectation{
		mock:               mmIsTokenRevoked.mock,
		params:             &TokenRepositoryMockIsTokenRevokedParams{ctx, refreshToken},
		expectationOrigins: TokenRepositoryMockIsTokenRevokedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsTokenRevoked.expectations = append(mmIsTokenRevoked.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.IsTokenRevoked return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockIsTokenRevokedExpectation) Then(b1 bool, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockIsTokenRevokedResults{b1, err}
	return e.mock
}

// Times sets number of times TokenRepository.IsTokenRevoked should be invoked
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Times(n uint64) *mTokenRepositoryMockIsTokenRevoked {
	if n == 0 {
		mmIsTokenRevoked.mock.t.Fatalf("Times of TokenRepositoryMock.IsTokenRevoked mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsTokenRevoked.expectedInvocations, n)
	mmIsTokenRevoked.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsTokenRevoked
}

func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) invocationsDone() bool {
	if len(mmIsTokenRevoked.expectations) == 0 && mmIsTokenRevoked.defaultExpectation == nil && mmIsTokenRevoked.mock.funcIsTokenRevoked == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsTokenRevoked.mock.afterIsTokenRevokedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsTokenRevoked.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsTokenRevoked implements mm_repository.TokenRepository
func (mmIsTokenRevoked *TokenRepositoryMock) IsTokenRevoked(ctx context.Context, refreshToken string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsTokenRevoked.beforeIsTokenRevokedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsTokenRevoked.afterIsTokenRevokedCounter, 1)

	mmIsTokenRevoked.t.Helper()

	if mmIsTokenRevoked.inspectFuncIsTokenRevoked != nil {
		mmIsTokenRevoked.inspectFuncIsTokenRevoked(ctx, refreshToken)
	}

	mm_params := TokenRepositoryMockIsTokenRevokedParams{ctx, refreshToken}

	// Record call args
	mmIsTokenRevoked.IsTokenRevokedMock.mutex.Lock()
	mmIsTokenRevoked.IsTokenRevokedMock.callArgs = append(mmIsTokenRevoked.IsTokenRevokedMock.callArgs, &mm_params)
	mmIsTokenRevoked.IsTokenRevokedMock.mutex.Unlock()

	for _, e := range mmIsTokenRevoked.IsTokenRevokedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.params
		mm_want_ptrs := mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockIsTokenRevokedParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsTokenRevoked.t.Errorf("TokenRepositoryMock.IsTokenRevoked got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmIsTokenRevoked.t.Errorf("TokenRepositoryMock.IsTokenRevoked got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsTokenRevoked.t.Errorf("TokenRepositoryMock.IsTokenRevoked got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsTokenRevoked.IsTokenRevokedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsTokenRevoked.t.Fatal("No results are set for the TokenRepositoryMock.IsTokenRevoked")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsTokenRevoked.funcIsTokenRevoked != nil {
		return mmIsTokenRevoked.funcIsTokenRevoked(ctx, refreshToken)
	}
	mmIsTokenRevoked.t.Fatalf("Unexpected call to TokenRepositoryMock.IsTokenRevoked. %v %v", ctx, refreshToken)
	return
}

// IsTokenRevokedAfterCounter returns a count of finished TokenRepositoryMock.IsTokenRevoked invocations
func (mmIsTokenRevoked *TokenRepositoryMock) IsTokenRevokedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTokenRevoked.afterIsTokenRevokedCounter)
}

// IsTokenRevokedBeforeCounter returns a count of TokenRepositoryMock.IsTokenRevoked invocations
func (mmIsTokenRevoked *TokenRepositoryMock) IsTokenRevokedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTokenRevoked.beforeIsTokenRevokedCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.IsTokenRevoked.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsTokenRevoked *mTokenRepositoryMockIsTokenRevoked) Calls() []*TokenRepositoryMockIsTokenRevokedParams {
	mmIsTokenRevoked.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockIsTokenRevokedParams, len(mmIsTokenRevoked.callArgs))
	copy(argCopy, mmIsTokenRevoked.callArgs)

	mmIsTokenRevoked.mutex.RUnlock()

	return argCopy
}

// MinimockIsTokenRevokedDone returns true if the count of the IsTokenRevoked invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockIsTokenRevokedDone() bool {
	if m.IsTokenRevokedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsTokenRevokedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsTokenRevokedMock.invocationsDone()
}

// MinimockIsTokenRevokedInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockIsTokenRevokedInspect() {
	for _, e := range m.IsTokenRevokedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.IsTokenRevoked at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsTokenRevokedCounter := mm_atomic.LoadUint64(&m.afterIsTokenRevokedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsTokenRevokedMock.defaultExpectation != nil && afterIsTokenRevokedCounter < 1 {
		if m.IsTokenRevokedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.IsTokenRevoked at\n%s", m.IsTokenRevokedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.IsTokenRevoked at\n%s with params: %#v", m.IsTokenRevokedMock.defaultExpectation.expectationOrigins.origin, *m.IsTokenRevokedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsTokenRevoked != nil && afterIsTokenRevokedCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.IsTokenRevoked at\n%s", m.funcIsTokenRevokedOrigin)
	}

	if !m.IsTokenRevokedMock.invocationsDone() && afterIsTokenRevokedCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.IsTokenRevoked at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsTokenRevokedMock.expectedInvocations), m.IsTokenRevokedMock.expectedInvocationsOrigin, afterIsTokenRevokedCounter)
	}
}

type mTokenRepositoryMockSetTokenVersion struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockSetTokenVersionExpectation
	expectations       []*TokenRepositoryMockSetTokenVersionExpectation

	callArgs []*TokenRepositoryMockSetTokenVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockSetTokenVersionExpectation specifies expectation struct of the TokenRepository.SetTokenVersion
type TokenRepositoryMockSetTokenVersionExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockSetTokenVersionParams
	paramPtrs          *TokenRepositoryMockSetTokenVersionParamPtrs
	expectationOrigins TokenRepositoryMockSetTokenVersionExpectationOrigins
	results            *TokenRepositoryMockSetTokenVersionResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockSetTokenVersionParams contains parameters of the TokenRepository.SetTokenVersion
type TokenRepositoryMockSetTokenVersionParams struct {
	ctx     context.Context
	userID  string
	version int
}

// TokenRepositoryMockSetTokenVersionParamPtrs contains pointers to parameters of the TokenRepository.SetTokenVersion
type TokenRepositoryMockSetTokenVersionParamPtrs struct {
	ctx     *context.Context
	userID  *string
	version *int
}

// TokenRepositoryMockSetTokenVersionResults contains results of the TokenRepository.SetTokenVersion
type TokenRepositoryMockSetTokenVersionResults struct {
	err error
}

// TokenRepositoryMockSetTokenVersionOrigins contains origins of expectations of the TokenRepository.SetTokenVersion
type TokenRepositoryMockSetTokenVersionExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originVersion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Optional() *mTokenRepositoryMockSetTokenVersion {
	mmSetTokenVersion.optional = true
	return mmSetTokenVersion
}

// Expect sets up expected params for TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Expect(ctx context.Context, userID string, version int) *mTokenRepositoryMockSetTokenVersion {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	if mmSetTokenVersion.defaultExpectation == nil {
		mmSetTokenVersion.defaultExpectation = &TokenRepositoryMockSetTokenVersionExpectation{}
	}

	if mmSetTokenVersion.defaultExpectation.paramPtrs != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by ExpectParams functions")
	}

	mmSetTokenVersion.defaultExpectation.params = &TokenRepositoryMockSetTokenVersionParams{ctx, userID, version}
	mmSetTokenVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetTokenVersion.expectations {
		if minimock.Equal(e.params, mmSetTokenVersion.defaultExpectation.params) {
			mmSetTokenVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTokenVersion.defaultExpectation.params)
		}
	}

	return mmSetTokenVersion
}

// ExpectCtxParam1 sets up expected param ctx for TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) ExpectCtxParam1(ctx context.Context) *mTokenRepositoryMockSetTokenVersion {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	if mmSetTokenVersion.defaultExpectation == nil {
		mmSetTokenVersion.defaultExpectation = &TokenRepositoryMockSetTokenVersionExpectation{}
	}

	if mmSetTokenVersion.defaultExpectation.params != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Expect")
	}

	if mmSetTokenVersion.defaultExpectation.paramPtrs == nil {
		mmSetTokenVersion.defaultExpectation.paramPtrs = &TokenRepositoryMockSetTokenVersionParamPtrs{}
	}
	mmSetTokenVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetTokenVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetTokenVersion
}

// ExpectUserIDParam2 sets up expected param userID for TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) ExpectUserIDParam2(userID string) *mTokenRepositoryMockSetTokenVersion {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	if mmSetTokenVersion.defaultExpectation == nil {
		mmSetTokenVersion.defaultExpectation = &TokenRepositoryMockSetTokenVersionExpectation{}
	}

	if mmSetTokenVersion.defaultExpectation.params != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Expect")
	}

	if mmSetTokenVersion.defaultExpectation.paramPtrs == nil {
		mmSetTokenVersion.defaultExpectation.paramPtrs = &TokenRepositoryMockSetTokenVersionParamPtrs{}
	}
	mmSetTokenVersion.defaultExpectation.paramPtrs.userID = &userID
	mmSetTokenVersion.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmSetTokenVersion
}

// ExpectVersionParam3 sets up expected param version for TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) ExpectVersionParam3(version int) *mTokenRepositoryMockSetTokenVersion {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	if mmSetTokenVersion.defaultExpectation == nil {
		mmSetTokenVersion.defaultExpectation = &TokenRepositoryMockSetTokenVersionExpectation{}
	}

	if mmSetTokenVersion.defaultExpectation.params != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Expect")
	}

	if mmSetTokenVersion.defaultExpectation.paramPtrs == nil {
		mmSetTokenVersion.defaultExpectation.paramPtrs = &TokenRepositoryMockSetTokenVersionParamPtrs{}
	}
	mmSetTokenVersion.defaultExpectation.paramPtrs.version = &version
	mmSetTokenVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmSetTokenVersion
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Inspect(f func(ctx context.Context, userID string, version int)) *mTokenRepositoryMockSetTokenVersion {
	if mmSetTokenVersion.mock.inspectFuncSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.SetTokenVersion")
	}

	mmSetTokenVersion.mock.inspectFuncSetTokenVersion = f

	return mmSetTokenVersion
}

// Return sets up results that will be returned by TokenRepository.SetTokenVersion
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Return(err error) *TokenRepositoryMock {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	if mmSetTokenVersion.defaultExpectation == nil {
		mmSetTokenVersion.defaultExpectation = &TokenRepositoryMockSetTokenVersionExpectation{mock: mmSetTokenVersion.mock}
	}
	mmSetTokenVersion.defaultExpectation.results = &TokenRepositoryMockSetTokenVersionResults{err}
	mmSetTokenVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetTokenVersion.mock
}

// Set uses given function f to mock the TokenRepository.SetTokenVersion method
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Set(f func(ctx context.Context, userID string, version int) (err error)) *TokenRepositoryMock {
	if mmSetTokenVersion.defaultExpectation != nil {
		mmSetTokenVersion.mock.t.Fatalf("Default expectation is already set for the TokenRepository.SetTokenVersion method")
	}

	if len(mmSetTokenVersion.expectations) > 0 {
		mmSetTokenVersion.mock.t.Fatalf("Some expectations are already set for the TokenRepository.SetTokenVersion method")
	}

	mmSetTokenVersion.mock.funcSetTokenVersion = f
	mmSetTokenVersion.mock.funcSetTokenVersionOrigin = minimock.CallerInfo(1)
	return mmSetTokenVersion.mock
}

// When sets expectation for the TokenRepository.SetTokenVersion which will trigger the result defined by the following
// Then helper
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) When(ctx context.Context, userID string, version int) *TokenRepositoryMockSetTokenVersionExpectation {
	if mmSetTokenVersion.mock.funcSetTokenVersion != nil {
		mmSetTokenVersion.mock.t.Fatalf("TokenRepositoryMock.SetTokenVersion mock is already set by Set")
	}

	expectation := &TokenRepositoryMockSetTokenVersionExpectation{
		mock:               mmSetTokenVersion.mock,
		params:             &TokenRepositoryMockSetTokenVersionParams{ctx, userID, version},
		expectationOrigins: TokenRepositoryMockSetTokenVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetTokenVersion.expectations = append(mmSetTokenVersion.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.SetTokenVersion return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockSetTokenVersionExpectation) Then(err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockSetTokenVersionResults{err}
	return e.mock
}

// Times sets number of times TokenRepository.SetTokenVersion should be invoked
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Times(n uint64) *mTokenRepositoryMockSetTokenVersion {
	if n == 0 {
		mmSetTokenVersion.mock.t.Fatalf("Times of TokenRepositoryMock.SetTokenVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetTokenVersion.expectedInvocations, n)
	mmSetTokenVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetTokenVersion
}

func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) invocationsDone() bool {
	if len(mmSetTokenVersion.expectations) == 0 && mmSetTokenVersion.defaultExpectation == nil && mmSetTokenVersion.mock.funcSetTokenVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetTokenVersion.mock.afterSetTokenVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetTokenVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetTokenVersion implements mm_repository.TokenRepository
func (mmSetTokenVersion *TokenRepositoryMock) SetTokenVersion(ctx context.Context, userID string, version int) (err error) {
	mm_atomic.AddUint64(&mmSetTokenVersion.beforeSetTokenVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTokenVersion.afterSetTokenVersionCounter, 1)

	mmSetTokenVersion.t.Helper()

	if mmSetTokenVersion.inspectFuncSetTokenVersion != nil {
		mmSetTokenVersion.inspectFuncSetTokenVersion(ctx, userID, version)
	}

	mm_params := TokenRepositoryMockSetTokenVersionParams{ctx, userID, version}

	// Record call args
	mmSetTokenVersion.SetTokenVersionMock.mutex.Lock()
	mmSetTokenVersion.SetTokenVersionMock.callArgs = append(mmSetTokenVersion.SetTokenVersionMock.callArgs, &mm_params)
	mmSetTokenVersion.SetTokenVersionMock.mutex.Unlock()

	for _, e := range mmSetTokenVersion.SetTokenVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetTokenVersion.SetTokenVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.params
		mm_want_ptrs := mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockSetTokenVersionParams{ctx, userID, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetTokenVersion.t.Errorf("TokenRepositoryMock.SetTokenVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmSetTokenVersion.t.Errorf("TokenRepositoryMock.SetTokenVersion got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmSetTokenVersion.t.Errorf("TokenRepositoryMock.SetTokenVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTokenVersion.t.Errorf("TokenRepositoryMock.SetTokenVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetTokenVersion.SetTokenVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetTokenVersion.t.Fatal("No results are set for the TokenRepositoryMock.SetTokenVersion")
		}
		return (*mm_results).err
	}
	if mmSetTokenVersion.funcSetTokenVersion != nil {
		return mmSetTokenVersion.funcSetTokenVersion(ctx, userID, version)
	}
	mmSetTokenVersion.t.Fatalf("Unexpected call to TokenRepositoryMock.SetTokenVersion. %v %v %v", ctx, userID, version)
	return
}

// SetTokenVersionAfterCounter returns a count of finished TokenRepositoryMock.SetTokenVersion invocations
func (mmSetTokenVersion *TokenRepositoryMock) SetTokenVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTokenVersion.afterSetTokenVersionCounter)
}

// SetTokenVersionBeforeCounter returns a count of TokenRepositoryMock.SetTokenVersion invocations
func (mmSetTokenVersion *TokenRepositoryMock) SetTokenVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTokenVersion.beforeSetTokenVersionCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.SetTokenVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTokenVersion *mTokenRepositoryMockSetTokenVersion) Calls() []*TokenRepositoryMockSetTokenVersionParams {
	mmSetTokenVersion.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockSetTokenVersionParams, len(mmSetTokenVersion.callArgs))
	copy(argCopy, mmSetTokenVersion.callArgs)

	mmSetTokenVersion.mutex.RUnlock()

	return argCopy
}

// MinimockSetTokenVersionDone returns true if the count of the SetTokenVersion invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockSetTokenVersionDone() bool {
	if m.SetTokenVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetTokenVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetTokenVersionMock.invocationsDone()
}

// MinimockSetTokenVersionInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockSetTokenVersionInspect() {
	for _, e := range m.SetTokenVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.SetTokenVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetTokenVersionCounter := mm_atomic.LoadUint64(&m.afterSetTokenVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetTokenVersionMock.defaultExpectation != nil && afterSetTokenVersionCounter < 1 {
		if m.SetTokenVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.SetTokenVersion at\n%s", m.SetTokenVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.SetTokenVersion at\n%s with params: %#v", m.SetTokenVersionMock.defaultExpectation.expectationOrigins.origin, *m.SetTokenVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTokenVersion != nil && afterSetTokenVersionCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.SetTokenVersion at\n%s", m.funcSetTokenVersionOrigin)
	}

	if !m.SetTokenVersionMock.invocationsDone() && afterSetTokenVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.SetTokenVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetTokenVersionMock.expectedInvocations), m.SetTokenVersionMock.expectedInvocationsOrigin, afterSetTokenVersionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TokenRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddRevokedTokenInspect()

			m.MinimockGetTokenVersionInspect()

			m.MinimockIsTokenRevokedInspect()

			m.MinimockSetTokenVersionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TokenRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TokenRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRevokedTokenDone() &&
		m.MinimockGetTokenVersionDone() &&
		m.MinimockIsTokenRevokedDone() &&
		m.MinimockSetTokenVersionDone()
}
